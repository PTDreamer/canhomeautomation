CCS PCH C Compiler, Version 4.057, 10706               11-Out-08 22:50

               Filename: C:\DomoticaNovo\Estores\ProgramaPIC\estores.lst

               ROM used: 16298 bytes (99%)
                         Largest free fragment is 82
               RAM used: 199 (26%) at main() level
                         287 (37%) worst case
               Stack:    8 worst case (3 in main + 5 for interrupts)

*
0000:  GOTO   38E0
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.5
004E:  GOTO   0058
0052:  BTFSC  F9E.5
0054:  GOTO   1556
0058:  BTFSS  FA0.2
005A:  GOTO   0064
005E:  BTFSC  FA1.2
0060:  GOTO   156C
0064:  BTFSS  FA3.7
0066:  GOTO   0070
006A:  BTFSC  FA4.7
006C:  GOTO   2376
0070:  BTFSS  FA3.5
0072:  GOTO   007C
0076:  BTFSC  FA4.5
0078:  GOTO   239A
007C:  BTFSS  FA3.4
007E:  GOTO   0088
0082:  BTFSC  FA4.4
0084:  GOTO   236E
0088:  BTFSS  FA3.3
008A:  GOTO   0094
008E:  BTFSC  FA4.3
0090:  GOTO   2366
0094:  BTFSS  FA3.2
0096:  GOTO   00A0
009A:  BTFSC  FA4.2
009C:  GOTO   235E
00A0:  BTFSS  FA3.1
00A2:  GOTO   00AC
00A6:  BTFSC  FA4.1
00A8:  GOTO   1ED6
00AC:  BTFSS  FA3.0
00AE:  GOTO   00B8
00B2:  BTFSC  FA4.0
00B4:  GOTO   1EAA
00B8:  BTFSS  FA0.7
00BA:  GOTO   00C4
00BE:  BTFSC  FA1.7
00C0:  GOTO   158C
00C4:  MOVFF  0F,00
00C8:  MOVFF  10,01
00CC:  MOVFF  11,02
00D0:  MOVFF  12,03
00D4:  MOVFF  13,04
00D8:  BSF    0E.7
00DA:  MOVFF  0D,FE9
00DE:  MOVFF  08,FEA
00E2:  MOVFF  09,FE1
00E6:  MOVFF  0A,FE2
00EA:  MOVFF  0B,FD9
00EE:  MOVFF  0C,FDA
00F2:  MOVFF  14,FF3
00F6:  MOVFF  15,FF4
00FA:  MOVFF  16,FFA
00FE:  MOVF   05,W
0100:  MOVFF  07,FE0
0104:  MOVFF  06,FD8
0108:  RETFIE 0
....................  
.................... #define inte0 pin_a0 
.................... #define inte1 pin_a1 
.................... #define inte2 pin_a2 
.................... #define inte3 pin_a3 
.................... #define inte4 pin_a4 
.................... #define inte5 pin_a5 
.................... #define inte6 pin_b1 
.................... #define inte7 pin_b0 
....................  
....................  
.................... #include "C:\DomoticaNovo\Estores\ProgramaPIC\estores.h" 
.................... #include <18F2480.h> 
.................... //////// Standard Header file for the PIC18F2480 device //////////////// 
.................... #device PIC18F2480 
.................... #list 
....................  
.................... #device adc=8 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... //#fuses NOWDT 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... //#FUSES BORV28                   //Brownout reset at 2.8V 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES BBSIZ2K                  //2K words Boot Block size 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOMCLR                     //Master Clear pin enabled 
.................... #FUSES NOXINST                    //Extended set extension and Indexed Addressing mode enabled 
....................  
.................... #use delay(clock=20000000,RESTART_WDT) 
*
1F02:  MOVLW  01
1F04:  MOVWF  FEA
1F06:  MOVWF  FE9
1F08:  MOVF   FEF,W
1F0A:  BZ    1F2E
1F0C:  MOVLW  06
1F0E:  MOVWF  01
1F10:  MOVLW  BF
1F12:  MOVWF  00
1F14:  CLRWDT
1F16:  DECFSZ 00,F
1F18:  BRA    1F14
1F1A:  DECFSZ 01,F
1F1C:  BRA    1F10
1F1E:  MOVLW  7A
1F20:  MOVWF  00
1F22:  DECFSZ 00,F
1F24:  BRA    1F22
1F26:  BRA    1F28
1F28:  CLRWDT
1F2A:  DECFSZ FEF,F
1F2C:  BRA    1F0C
1F2E:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,restart_wdt) 
....................  
....................  
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
240A:  CLRF   xE8
....................    sign = 0; 
240C:  CLRF   xE6
....................    base = 10; 
240E:  MOVLW  0A
2410:  MOVWF  xE7
....................    result = 0; 
2412:  CLRF   xE5
....................  
....................    if (!s) 
2414:  MOVF   xE3,W
2416:  IORWF  xE4,W
2418:  BNZ   2420
....................       return 0; 
241A:  MOVLW  00
241C:  MOVWF  01
241E:  BRA    25A2
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
2420:  MOVF   xE8,W
2422:  INCF   xE8,F
2424:  CLRF   03
2426:  ADDWF  xE3,W
2428:  MOVWF  FE9
242A:  MOVF   xE4,W
242C:  ADDWFC 03,W
242E:  MOVWF  FEA
2430:  MOVFF  FEF,E9
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
2434:  MOVF   xE9,W
2436:  SUBLW  2D
2438:  BNZ   2454
....................    { 
....................       sign = 1;         // Set the sign to negative 
243A:  MOVLW  01
243C:  MOVWF  xE6
....................       c = s[index++]; 
243E:  MOVF   xE8,W
2440:  INCF   xE8,F
2442:  CLRF   03
2444:  ADDWF  xE3,W
2446:  MOVWF  FE9
2448:  MOVF   xE4,W
244A:  ADDWFC 03,W
244C:  MOVWF  FEA
244E:  MOVFF  FEF,E9
....................    } 
....................    else if (c == '+') 
2452:  BRA    246E
2454:  MOVF   xE9,W
2456:  SUBLW  2B
2458:  BNZ   246E
....................    { 
....................       c = s[index++]; 
245A:  MOVF   xE8,W
245C:  INCF   xE8,F
245E:  CLRF   03
2460:  ADDWF  xE3,W
2462:  MOVWF  FE9
2464:  MOVF   xE4,W
2466:  ADDWFC 03,W
2468:  MOVWF  FEA
246A:  MOVFF  FEF,E9
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
246E:  MOVF   xE9,W
2470:  SUBLW  2F
2472:  BTFSC  FD8.0
2474:  BRA    2592
2476:  MOVF   xE9,W
2478:  SUBLW  39
247A:  BTFSS  FD8.0
247C:  BRA    2592
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
247E:  MOVF   xE9,W
2480:  SUBLW  30
2482:  BNZ   24C6
2484:  CLRF   03
2486:  MOVF   xE8,W
2488:  ADDWF  xE3,W
248A:  MOVWF  FE9
248C:  MOVF   xE4,W
248E:  ADDWFC 03,W
2490:  MOVWF  FEA
2492:  MOVF   FEF,W
2494:  SUBLW  78
2496:  BZ    24AC
2498:  CLRF   03
249A:  MOVF   xE8,W
249C:  ADDWF  xE3,W
249E:  MOVWF  FE9
24A0:  MOVF   xE4,W
24A2:  ADDWFC 03,W
24A4:  MOVWF  FEA
24A6:  MOVF   FEF,W
24A8:  SUBLW  58
24AA:  BNZ   24C6
....................       { 
....................          base = 16; 
24AC:  MOVLW  10
24AE:  MOVWF  xE7
....................          index++; 
24B0:  INCF   xE8,F
....................          c = s[index++]; 
24B2:  MOVF   xE8,W
24B4:  INCF   xE8,F
24B6:  CLRF   03
24B8:  ADDWF  xE3,W
24BA:  MOVWF  FE9
24BC:  MOVF   xE4,W
24BE:  ADDWFC 03,W
24C0:  MOVWF  FEA
24C2:  MOVFF  FEF,E9
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
24C6:  MOVF   xE7,W
24C8:  SUBLW  0A
24CA:  BNZ   2502
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
24CC:  MOVF   xE9,W
24CE:  SUBLW  2F
24D0:  BC    2500
24D2:  MOVF   xE9,W
24D4:  SUBLW  39
24D6:  BNC   2500
....................             result = 10*result + (c - '0'); 
24D8:  MOVLW  0A
24DA:  MOVWF  xEA
24DC:  MOVFF  E5,EB
24E0:  BRA    23BE
24E2:  MOVLW  30
24E4:  SUBWF  xE9,W
24E6:  ADDWF  01,W
24E8:  MOVWF  xE5
....................             c = s[index++]; 
24EA:  MOVF   xE8,W
24EC:  INCF   xE8,F
24EE:  CLRF   03
24F0:  ADDWF  xE3,W
24F2:  MOVWF  FE9
24F4:  MOVF   xE4,W
24F6:  ADDWFC 03,W
24F8:  MOVWF  FEA
24FA:  MOVFF  FEF,E9
....................          } 
24FE:  BRA    24CC
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2500:  BRA    2592
2502:  MOVF   xE7,W
2504:  SUBLW  10
2506:  BNZ   2592
....................       { 
....................          c = toupper(c); 
2508:  MOVF   xE9,W
250A:  SUBLW  60
250C:  BC    251A
250E:  MOVF   xE9,W
2510:  SUBLW  7A
2512:  BNC   251A
2514:  MOVF   xE9,W
2516:  ANDLW  DF
2518:  BRA    251C
251A:  MOVF   xE9,W
251C:  MOVWF  xE9
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
251E:  MOVF   xE9,W
2520:  SUBLW  2F
2522:  BC    252A
2524:  MOVF   xE9,W
2526:  SUBLW  39
2528:  BC    2536
252A:  MOVF   xE9,W
252C:  SUBLW  40
252E:  BC    2592
2530:  MOVF   xE9,W
2532:  SUBLW  46
2534:  BNC   2592
....................             if (c >= '0' && c <= '9') 
2536:  MOVF   xE9,W
2538:  SUBLW  2F
253A:  BC    2554
253C:  MOVF   xE9,W
253E:  SUBLW  39
2540:  BNC   2554
....................                result = (result << 4) + (c - '0'); 
2542:  SWAPF  xE5,W
2544:  MOVWF  xEA
2546:  MOVLW  F0
2548:  ANDWF  xEA,F
254A:  MOVLW  30
254C:  SUBWF  xE9,W
254E:  ADDWF  xEA,W
2550:  MOVWF  xE5
....................             else 
2552:  BRA    2566
....................                result = (result << 4) + (c - 'A' + 10); 
2554:  SWAPF  xE5,W
2556:  MOVWF  xEA
2558:  MOVLW  F0
255A:  ANDWF  xEA,F
255C:  MOVLW  41
255E:  SUBWF  xE9,W
2560:  ADDLW  0A
2562:  ADDWF  xEA,W
2564:  MOVWF  xE5
....................  
....................             c = s[index++]; 
2566:  MOVF   xE8,W
2568:  INCF   xE8,F
256A:  CLRF   03
256C:  ADDWF  xE3,W
256E:  MOVWF  FE9
2570:  MOVF   xE4,W
2572:  ADDWFC 03,W
2574:  MOVWF  FEA
2576:  MOVFF  FEF,E9
....................             c = toupper(c); 
257A:  MOVF   xE9,W
257C:  SUBLW  60
257E:  BC    258C
2580:  MOVF   xE9,W
2582:  SUBLW  7A
2584:  BNC   258C
2586:  MOVF   xE9,W
2588:  ANDLW  DF
258A:  BRA    258E
258C:  MOVF   xE9,W
258E:  MOVWF  xE9
....................          } 
2590:  BRA    251E
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
2592:  DECFSZ xE6,W
2594:  BRA    259E
2596:  MOVF   xE7,W
2598:  SUBLW  0A
259A:  BNZ   259E
....................        result = -result; 
259C:  NEGF   xE5
....................  
....................    return(result); 
259E:  MOVFF  E5,01
.................... } 
25A2:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "C:\DomoticaNovo\Estores\ProgramaPIC\max4896.c" 
.................... #define CS pin_c2 
.................... #define delayMAX 300 
....................  
.................... int relevalue=0; 
....................  
.................... void write4896(value) 
.................... { 
.................... relevalue=value; 
*
1186:  MOVFF  F4,1F
.................... output_low(CS); 
118A:  BCF    F94.2
118C:  BCF    F8B.2
.................... spi_write(value); 
118E:  MOVF   FC9,W
1190:  MOVFF  F4,FC9
1194:  BTFSS  FC7.0
1196:  BRA    1194
.................... output_high(CS); 
1198:  BCF    F94.2
119A:  BSF    F8B.2
....................  
.................... } 
119C:  RETLW  00
....................  
....................  
....................  
....................  
.................... #include "C:\DomoticaNovo\Estores\ProgramaPIC\console.c" 
.................... char lastcommand; 
.................... int1 can_Pop ( int32 & rx_id, int * buffer, int & rx_len, int & rx_stat ); 
.................... int catoi(char c) 
.................... { 
.................... switch (c) { 
*
1104:  MOVLW  30
1106:  SUBWF  xF4,W
1108:  ADDLW  F8
110A:  BC    1158
110C:  ADDLW  08
110E:  GOTO   115C
....................  
....................     case '0':return 0; 
1112:  MOVLW  00
1114:  MOVWF  01
1116:  BRA    1158
....................  
....................            break; 
1118:  BRA    1158
....................  
....................     case '1':return 1; 
111A:  MOVLW  01
111C:  MOVWF  01
111E:  BRA    1158
....................  
....................            break; 
1120:  BRA    1158
....................      
....................     case '2':return 2; 
1122:  MOVLW  02
1124:  MOVWF  01
1126:  BRA    1158
....................  
....................            break; 
1128:  BRA    1158
....................  
....................     case '3':return 3; 
112A:  MOVLW  03
112C:  MOVWF  01
112E:  BRA    1158
....................  
....................            break; 
1130:  BRA    1158
....................  
....................     case '4':return 4; 
1132:  MOVLW  04
1134:  MOVWF  01
1136:  BRA    1158
....................  
....................            break; 
1138:  BRA    1158
....................     case '5':return 5; 
113A:  MOVLW  05
113C:  MOVWF  01
113E:  BRA    1158
....................  
....................            break; 
1140:  BRA    1158
....................      
....................     case '6':return 6; 
1142:  MOVLW  06
1144:  MOVWF  01
1146:  BRA    1158
....................  
....................            break; 
1148:  BRA    1158
....................      
....................     case '7':return 7; 
114A:  MOVLW  07
114C:  MOVWF  01
114E:  BRA    1158
....................  
....................            break; 
1150:  BRA    1158
....................     return 0; 
1152:  MOVLW  00
1154:  MOVWF  01
1156:  BRA    1158
.................... } 
.................... } 
1158:  GOTO   13B8 (RETURN)
.................... void printCAN() 
.................... { 
....................    if(lastcommand=='a') 
*
1B4E:  MOVF   20,W
1B50:  SUBLW  61
1B52:  BTFSS  FD8.2
1B54:  BRA    1EA6
....................    { 
....................       int32 prxid; 
....................       int prxl,prxs,x; 
....................       int pbuffer[8]; 
....................       can_Pop(prxid,pbuffer,prxl,prxs); 
1B56:  MOVLB  1
1B58:  CLRF   x03
1B5A:  MOVLW  F8
1B5C:  MOVWF  x02
....................       printf("\n\r"); 
*
1CC4:  MOVLW  0A
1CC6:  CLRWDT
1CC8:  BTFSS  F9E.4
1CCA:  BRA    1CC6
1CCC:  MOVWF  FAD
1CCE:  MOVLW  0D
1CD0:  CLRWDT
1CD2:  BTFSS  F9E.4
1CD4:  BRA    1CD0
1CD6:  MOVWF  FAD
....................       printf("**************\n\r"); 
1CD8:  CLRF   x00
1CDA:  MOVF   x00,W
1CDC:  MOVLB  0
1CDE:  CALL   010A
1CE2:  MOVLB  1
1CE4:  INCF   x00,F
1CE6:  MOVWF  00
1CE8:  CLRWDT
1CEA:  BTFSS  F9E.4
1CEC:  BRA    1CE8
1CEE:  MOVWF  FAD
1CF0:  MOVLW  10
1CF2:  SUBWF  x00,W
1CF4:  BNZ   1CDA
....................       printf("* CAN Message*\n\r"); 
1CF6:  CLRF   x00
1CF8:  MOVF   x00,W
1CFA:  MOVLB  0
1CFC:  CALL   012C
1D00:  MOVLB  1
1D02:  INCF   x00,F
1D04:  MOVWF  00
1D06:  CLRWDT
1D08:  BTFSS  F9E.4
1D0A:  BRA    1D06
1D0C:  MOVWF  FAD
1D0E:  MOVLW  10
1D10:  SUBWF  x00,W
1D12:  BNZ   1CF8
....................       printf("* ID    =%X  *\n\r",prxid); 
1D14:  CLRF   x00
1D16:  MOVF   x00,W
1D18:  MOVLB  0
1D1A:  CALL   014E
1D1E:  MOVLB  1
1D20:  INCF   x00,F
1D22:  MOVWF  00
1D24:  CLRWDT
1D26:  BTFSS  F9E.4
1D28:  BRA    1D24
1D2A:  MOVWF  FAD
1D2C:  MOVLW  09
1D2E:  SUBWF  x00,W
1D30:  BNZ   1D16
1D32:  MOVFF  F1,102
1D36:  MOVLW  37
1D38:  MOVWF  x03
1D3A:  MOVLB  0
1D3C:  RCALL  1B04
1D3E:  MOVLW  0B
1D40:  MOVLB  1
1D42:  MOVWF  x01
1D44:  MOVF   x01,W
1D46:  MOVLB  0
1D48:  CALL   014E
1D4C:  MOVLB  1
1D4E:  INCF   x01,F
1D50:  MOVWF  00
1D52:  CLRWDT
1D54:  BTFSS  F9E.4
1D56:  BRA    1D52
1D58:  MOVWF  FAD
1D5A:  MOVLW  10
1D5C:  SUBWF  x01,W
1D5E:  BNZ   1D44
....................       printf("* Lenght=%X  *\n\r",prxl); 
1D60:  CLRF   x00
1D62:  MOVF   x00,W
1D64:  MOVLB  0
1D66:  CALL   0170
1D6A:  MOVLB  1
1D6C:  INCF   x00,F
1D6E:  MOVWF  00
1D70:  CLRWDT
1D72:  BTFSS  F9E.4
1D74:  BRA    1D70
1D76:  MOVWF  FAD
1D78:  MOVLW  09
1D7A:  SUBWF  x00,W
1D7C:  BNZ   1D62
1D7E:  MOVFF  F5,102
1D82:  MOVLW  37
1D84:  MOVWF  x03
1D86:  MOVLB  0
1D88:  RCALL  1B04
1D8A:  MOVLW  0B
1D8C:  MOVLB  1
1D8E:  MOVWF  x01
1D90:  MOVF   x01,W
1D92:  MOVLB  0
1D94:  CALL   0170
1D98:  MOVLB  1
1D9A:  INCF   x01,F
1D9C:  MOVWF  00
1D9E:  CLRWDT
1DA0:  BTFSS  F9E.4
1DA2:  BRA    1D9E
1DA4:  MOVWF  FAD
1DA6:  MOVLW  10
1DA8:  SUBWF  x01,W
1DAA:  BNZ   1D90
....................       printf("* Stat  =%X  *\n\r",prxs); 
1DAC:  CLRF   x00
1DAE:  MOVF   x00,W
1DB0:  MOVLB  0
1DB2:  CALL   0192
1DB6:  MOVLB  1
1DB8:  INCF   x00,F
1DBA:  MOVWF  00
1DBC:  CLRWDT
1DBE:  BTFSS  F9E.4
1DC0:  BRA    1DBC
1DC2:  MOVWF  FAD
1DC4:  MOVLW  09
1DC6:  SUBWF  x00,W
1DC8:  BNZ   1DAE
1DCA:  MOVFF  F6,102
1DCE:  MOVLW  37
1DD0:  MOVWF  x03
1DD2:  MOVLB  0
1DD4:  RCALL  1B04
1DD6:  MOVLW  0B
1DD8:  MOVLB  1
1DDA:  MOVWF  x01
1DDC:  MOVF   x01,W
1DDE:  MOVLB  0
1DE0:  CALL   0192
1DE4:  MOVLB  1
1DE6:  INCF   x01,F
1DE8:  MOVWF  00
1DEA:  CLRWDT
1DEC:  BTFSS  F9E.4
1DEE:  BRA    1DEA
1DF0:  MOVWF  FAD
1DF2:  MOVLW  10
1DF4:  SUBWF  x01,W
1DF6:  BNZ   1DDC
....................       for(x=0;x<prxl;++x) 
1DF8:  MOVLB  0
1DFA:  CLRF   xF7
1DFC:  MOVF   xF5,W
1DFE:  SUBWF  xF7,W
1E00:  BC    1E86
....................       { 
....................       printf("* Data[%u]=%X*\n\r",x,pbuffer[x]); 
1E02:  CLRF   03
1E04:  MOVF   xF7,W
1E06:  ADDLW  F8
1E08:  MOVWF  FE9
1E0A:  MOVLW  00
1E0C:  ADDWFC 03,W
1E0E:  MOVWF  FEA
1E10:  MOVFF  FEF,100
1E14:  MOVLB  1
1E16:  CLRF   x01
1E18:  MOVF   x01,W
1E1A:  MOVLB  0
1E1C:  CALL   01B4
1E20:  MOVLB  1
1E22:  INCF   x01,F
1E24:  MOVWF  00
1E26:  CLRWDT
1E28:  BTFSS  F9E.4
1E2A:  BRA    1E26
1E2C:  MOVWF  FAD
1E2E:  MOVLW  07
1E30:  SUBWF  x01,W
1E32:  BNZ   1E18
1E34:  MOVFF  F7,102
1E38:  MOVLW  1B
1E3A:  MOVWF  x03
1E3C:  MOVLB  0
1E3E:  CALL   0ED6
1E42:  MOVLW  5D
1E44:  CLRWDT
1E46:  BTFSS  F9E.4
1E48:  BRA    1E44
1E4A:  MOVWF  FAD
1E4C:  MOVLW  3D
1E4E:  CLRWDT
1E50:  BTFSS  F9E.4
1E52:  BRA    1E4E
1E54:  MOVWF  FAD
1E56:  MOVFF  100,102
1E5A:  MOVLW  37
1E5C:  MOVLB  1
1E5E:  MOVWF  x03
1E60:  MOVLB  0
1E62:  RCALL  1B04
1E64:  MOVLW  2A
1E66:  CLRWDT
1E68:  BTFSS  F9E.4
1E6A:  BRA    1E66
1E6C:  MOVWF  FAD
1E6E:  MOVLW  0A
1E70:  CLRWDT
1E72:  BTFSS  F9E.4
1E74:  BRA    1E70
1E76:  MOVWF  FAD
1E78:  MOVLW  0D
1E7A:  CLRWDT
1E7C:  BTFSS  F9E.4
1E7E:  BRA    1E7A
1E80:  MOVWF  FAD
....................       } 
1E82:  INCF   xF7,F
1E84:  BRA    1DFC
....................       printf("**************\n\r"); 
1E86:  MOVLB  1
1E88:  CLRF   x00
1E8A:  MOVF   x00,W
1E8C:  MOVLB  0
1E8E:  CALL   010A
1E92:  MOVLB  1
1E94:  INCF   x00,F
1E96:  MOVWF  00
1E98:  CLRWDT
1E9A:  BTFSS  F9E.4
1E9C:  BRA    1E98
1E9E:  MOVWF  FAD
1EA0:  MOVLW  10
1EA2:  SUBWF  x00,W
1EA4:  BNZ   1E8A
1EA6:  MOVLB  0
....................    } 
.................... } 
1EA8:  RETLW  00
.................... void showconsole(void) 
.................... { 
.................... printf("\n\r"); 
*
0DDE:  MOVLW  0A
0DE0:  CLRWDT
0DE2:  BTFSS  F9E.4
0DE4:  BRA    0DE0
0DE6:  MOVWF  FAD
0DE8:  MOVLW  0D
0DEA:  CLRWDT
0DEC:  BTFSS  F9E.4
0DEE:  BRA    0DEA
0DF0:  MOVWF  FAD
.................... printf("**********************\n\r"); 
0DF2:  CLRF   xF4
0DF4:  MOVF   xF4,W
0DF6:  CALL   01D6
0DFA:  INCF   xF4,F
0DFC:  MOVWF  00
0DFE:  CLRWDT
0E00:  BTFSS  F9E.4
0E02:  BRA    0DFE
0E04:  MOVWF  FAD
0E06:  MOVLW  18
0E08:  SUBWF  xF4,W
0E0A:  BNZ   0DF4
.................... printf("* O-Control outputs  *\n\r"); 
0E0C:  CLRF   xF4
0E0E:  MOVF   xF4,W
0E10:  CALL   0212
0E14:  INCF   xF4,F
0E16:  MOVWF  00
0E18:  CLRWDT
0E1A:  BTFSS  F9E.4
0E1C:  BRA    0E18
0E1E:  MOVWF  FAD
0E20:  MOVLW  18
0E22:  SUBWF  xF4,W
0E24:  BNZ   0E0E
.................... printf("* I-View Inputs      *\n\r"); 
0E26:  CLRF   xF4
0E28:  MOVF   xF4,W
0E2A:  CALL   023C
0E2E:  INCF   xF4,F
0E30:  MOVWF  00
0E32:  CLRWDT
0E34:  BTFSS  F9E.4
0E36:  BRA    0E32
0E38:  MOVWF  FAD
0E3A:  MOVLW  18
0E3C:  SUBWF  xF4,W
0E3E:  BNZ   0E28
.................... printf("* A-Receive Can      *\n\r"); 
0E40:  CLRF   xF4
0E42:  MOVF   xF4,W
0E44:  CALL   0266
0E48:  INCF   xF4,F
0E4A:  MOVWF  00
0E4C:  CLRWDT
0E4E:  BTFSS  F9E.4
0E50:  BRA    0E4C
0E52:  MOVWF  FAD
0E54:  MOVLW  18
0E56:  SUBWF  xF4,W
0E58:  BNZ   0E42
.................... printf("* R-Read Register    *\n\r"); 
0E5A:  CLRF   xF4
0E5C:  MOVF   xF4,W
0E5E:  CALL   0290
0E62:  INCF   xF4,F
0E64:  MOVWF  00
0E66:  CLRWDT
0E68:  BTFSS  F9E.4
0E6A:  BRA    0E66
0E6C:  MOVWF  FAD
0E6E:  MOVLW  18
0E70:  SUBWF  xF4,W
0E72:  BNZ   0E5C
.................... printf("* W-Write Registers  *\n\r"); 
0E74:  CLRF   xF4
0E76:  MOVF   xF4,W
0E78:  CALL   02BA
0E7C:  INCF   xF4,F
0E7E:  MOVWF  00
0E80:  CLRWDT
0E82:  BTFSS  F9E.4
0E84:  BRA    0E80
0E86:  MOVWF  FAD
0E88:  MOVLW  18
0E8A:  SUBWF  xF4,W
0E8C:  BNZ   0E76
.................... printf("**********************\n\r"); 
0E8E:  CLRF   xF4
0E90:  MOVF   xF4,W
0E92:  CALL   01D6
0E96:  INCF   xF4,F
0E98:  MOVWF  00
0E9A:  CLRWDT
0E9C:  BTFSS  F9E.4
0E9E:  BRA    0E9A
0EA0:  MOVWF  FAD
0EA2:  MOVLW  18
0EA4:  SUBWF  xF4,W
0EA6:  BNZ   0E90
.................... } 
0EA8:  RETLW  00
....................  
....................  
.................... void showoutputs(void) 
.................... { 
.................... printf("\n\r"); 
*
0F5A:  MOVLW  0A
0F5C:  CLRWDT
0F5E:  BTFSS  F9E.4
0F60:  BRA    0F5C
0F62:  MOVWF  FAD
0F64:  MOVLW  0D
0F66:  CLRWDT
0F68:  BTFSS  F9E.4
0F6A:  BRA    0F66
0F6C:  MOVWF  FAD
.................... printf("***********************\n\r"); 
0F6E:  CLRF   xF4
0F70:  MOVF   xF4,W
0F72:  CALL   02E4
0F76:  INCF   xF4,F
0F78:  MOVWF  00
0F7A:  CLRWDT
0F7C:  BTFSS  F9E.4
0F7E:  BRA    0F7A
0F80:  MOVWF  FAD
0F82:  MOVLW  19
0F84:  SUBWF  xF4,W
0F86:  BNZ   0F70
.................... printf("* 0...7-Toggle output *\n\r"); 
0F88:  CLRF   xF4
0F8A:  MOVF   xF4,W
0F8C:  CALL   030E
0F90:  INCF   xF4,F
0F92:  MOVWF  00
0F94:  CLRWDT
0F96:  BTFSS  F9E.4
0F98:  BRA    0F94
0F9A:  MOVWF  FAD
0F9C:  MOVLW  19
0F9E:  SUBWF  xF4,W
0FA0:  BNZ   0F8A
.................... printf("* S-Sair              *\n\r"); 
0FA2:  CLRF   xF4
0FA4:  MOVF   xF4,W
0FA6:  CALL   0338
0FAA:  INCF   xF4,F
0FAC:  MOVWF  00
0FAE:  CLRWDT
0FB0:  BTFSS  F9E.4
0FB2:  BRA    0FAE
0FB4:  MOVWF  FAD
0FB6:  MOVLW  19
0FB8:  SUBWF  xF4,W
0FBA:  BNZ   0FA4
.................... printf("***********************\n\r"); 
0FBC:  CLRF   xF4
0FBE:  MOVF   xF4,W
0FC0:  CALL   02E4
0FC4:  INCF   xF4,F
0FC6:  MOVWF  00
0FC8:  CLRWDT
0FCA:  BTFSS  F9E.4
0FCC:  BRA    0FC8
0FCE:  MOVWF  FAD
0FD0:  MOVLW  19
0FD2:  SUBWF  xF4,W
0FD4:  BNZ   0FBE
.................... printf(" Rele 0 1 2 3 4 5 6 7\n\r"); 
0FD6:  CLRF   xF4
0FD8:  MOVF   xF4,W
0FDA:  CALL   0362
0FDE:  INCF   xF4,F
0FE0:  MOVWF  00
0FE2:  CLRWDT
0FE4:  BTFSS  F9E.4
0FE6:  BRA    0FE2
0FE8:  MOVWF  FAD
0FEA:  MOVLW  17
0FEC:  SUBWF  xF4,W
0FEE:  BNZ   0FD8
.................... printf("      %u %u %u %u %u %u %u %u",bit_test(relevalue,0),bit_test(relevalue,1),bit_test(relevalue,2),bit_test(relevalue,3),bit_test(relevalue,4),bit_test(relevalue,5),bit_test(relevalue,6),bit_test(relevalue,7)); 
0FF0:  MOVLW  00
0FF2:  BTFSC  1F.0
0FF4:  MOVLW  01
0FF6:  MOVWF  xF4
0FF8:  MOVLW  00
0FFA:  BTFSC  1F.1
0FFC:  MOVLW  01
0FFE:  MOVWF  xF5
1000:  MOVLW  00
1002:  BTFSC  1F.2
1004:  MOVLW  01
1006:  MOVWF  xF6
1008:  MOVLW  00
100A:  BTFSC  1F.3
100C:  MOVLW  01
100E:  MOVWF  xF7
1010:  MOVLW  00
1012:  BTFSC  1F.4
1014:  MOVLW  01
1016:  MOVWF  xF8
1018:  MOVLW  00
101A:  BTFSC  1F.5
101C:  MOVLW  01
101E:  MOVWF  xF9
1020:  MOVLW  00
1022:  BTFSC  1F.6
1024:  MOVLW  01
1026:  MOVWF  xFA
1028:  MOVLW  00
102A:  BTFSC  1F.7
102C:  MOVLW  01
102E:  MOVWF  xFB
1030:  CLRF   xFC
1032:  MOVF   xFC,W
1034:  CALL   038A
1038:  INCF   xFC,F
103A:  MOVWF  00
103C:  CLRWDT
103E:  BTFSS  F9E.4
1040:  BRA    103C
1042:  MOVWF  FAD
1044:  MOVLW  06
1046:  SUBWF  xFC,W
1048:  BNZ   1032
104A:  MOVFF  F4,102
104E:  MOVLW  1B
1050:  MOVLB  1
1052:  MOVWF  x03
1054:  MOVLB  0
1056:  RCALL  0ED6
1058:  MOVLW  20
105A:  CLRWDT
105C:  BTFSS  F9E.4
105E:  BRA    105A
1060:  MOVWF  FAD
1062:  MOVFF  F5,102
1066:  MOVLW  1B
1068:  MOVLB  1
106A:  MOVWF  x03
106C:  MOVLB  0
106E:  RCALL  0ED6
1070:  MOVLW  20
1072:  CLRWDT
1074:  BTFSS  F9E.4
1076:  BRA    1072
1078:  MOVWF  FAD
107A:  MOVFF  F6,102
107E:  MOVLW  1B
1080:  MOVLB  1
1082:  MOVWF  x03
1084:  MOVLB  0
1086:  RCALL  0ED6
1088:  MOVLW  20
108A:  CLRWDT
108C:  BTFSS  F9E.4
108E:  BRA    108A
1090:  MOVWF  FAD
1092:  MOVFF  F7,102
1096:  MOVLW  1B
1098:  MOVLB  1
109A:  MOVWF  x03
109C:  MOVLB  0
109E:  RCALL  0ED6
10A0:  MOVLW  20
10A2:  CLRWDT
10A4:  BTFSS  F9E.4
10A6:  BRA    10A2
10A8:  MOVWF  FAD
10AA:  MOVFF  F8,102
10AE:  MOVLW  1B
10B0:  MOVLB  1
10B2:  MOVWF  x03
10B4:  MOVLB  0
10B6:  RCALL  0ED6
10B8:  MOVLW  20
10BA:  CLRWDT
10BC:  BTFSS  F9E.4
10BE:  BRA    10BA
10C0:  MOVWF  FAD
10C2:  MOVFF  F9,102
10C6:  MOVLW  1B
10C8:  MOVLB  1
10CA:  MOVWF  x03
10CC:  MOVLB  0
10CE:  RCALL  0ED6
10D0:  MOVLW  20
10D2:  CLRWDT
10D4:  BTFSS  F9E.4
10D6:  BRA    10D2
10D8:  MOVWF  FAD
10DA:  MOVFF  FA,102
10DE:  MOVLW  1B
10E0:  MOVLB  1
10E2:  MOVWF  x03
10E4:  MOVLB  0
10E6:  RCALL  0ED6
10E8:  MOVLW  20
10EA:  CLRWDT
10EC:  BTFSS  F9E.4
10EE:  BRA    10EA
10F0:  MOVWF  FAD
10F2:  MOVFF  FB,102
10F6:  MOVLW  1B
10F8:  MOVLB  1
10FA:  MOVWF  x03
10FC:  MOVLB  0
10FE:  RCALL  0ED6
.................... } 
1100:  GOTO   136E (RETURN)
.................... void showinputs(void) 
.................... { 
.................... printf("\n\r"); 
*
119E:  MOVLW  0A
11A0:  CLRWDT
11A2:  BTFSS  F9E.4
11A4:  BRA    11A0
11A6:  MOVWF  FAD
11A8:  MOVLW  0D
11AA:  CLRWDT
11AC:  BTFSS  F9E.4
11AE:  BRA    11AA
11B0:  MOVWF  FAD
.................... printf("*****************************\n\r"); 
11B2:  CLRF   xF4
11B4:  MOVF   xF4,W
11B6:  CALL   03B8
11BA:  INCF   xF4,F
11BC:  MOVWF  00
11BE:  CLRWDT
11C0:  BTFSS  F9E.4
11C2:  BRA    11BE
11C4:  MOVWF  FAD
11C6:  MOVLW  1F
11C8:  SUBWF  xF4,W
11CA:  BNZ   11B4
.................... printf("* Qualquer tecla para sair  *\n\r"); 
11CC:  CLRF   xF4
11CE:  MOVF   xF4,W
11D0:  CALL   03FA
11D4:  INCF   xF4,F
11D6:  MOVWF  00
11D8:  CLRWDT
11DA:  BTFSS  F9E.4
11DC:  BRA    11D8
11DE:  MOVWF  FAD
11E0:  MOVLW  1F
11E2:  SUBWF  xF4,W
11E4:  BNZ   11CE
.................... printf("*****************************\n\r"); 
11E6:  CLRF   xF4
11E8:  MOVF   xF4,W
11EA:  CALL   03B8
11EE:  INCF   xF4,F
11F0:  MOVWF  00
11F2:  CLRWDT
11F4:  BTFSS  F9E.4
11F6:  BRA    11F2
11F8:  MOVWF  FAD
11FA:  MOVLW  1F
11FC:  SUBWF  xF4,W
11FE:  BNZ   11E8
.................... printf(" Int 0 1 2 3 4 5 6 7\n\r"); 
1200:  CLRF   xF4
1202:  MOVF   xF4,W
1204:  CALL   042A
1208:  INCF   xF4,F
120A:  MOVWF  00
120C:  CLRWDT
120E:  BTFSS  F9E.4
1210:  BRA    120C
1212:  MOVWF  FAD
1214:  MOVLW  16
1216:  SUBWF  xF4,W
1218:  BNZ   1202
.................... while(!Kbhit())printf("\r     %u %u %u %u %u %u %u %u",input(inte0),input(inte1),input(inte2),input(inte3),input(inte4),input(inte5),input(inte6),input(inte7)); 
121A:  BTFSC  F9E.5
121C:  BRA    1340
121E:  BSF    F92.0
1220:  MOVLW  00
1222:  BTFSC  F80.0
1224:  MOVLW  01
1226:  MOVWF  xF4
1228:  BSF    F92.1
122A:  MOVLW  00
122C:  BTFSC  F80.1
122E:  MOVLW  01
1230:  MOVWF  xF5
1232:  BSF    F92.2
1234:  MOVLW  00
1236:  BTFSC  F80.2
1238:  MOVLW  01
123A:  MOVWF  xF6
123C:  BSF    F92.3
123E:  MOVLW  00
1240:  BTFSC  F80.3
1242:  MOVLW  01
1244:  MOVWF  xF7
1246:  BSF    F92.4
1248:  MOVLW  00
124A:  BTFSC  F80.4
124C:  MOVLW  01
124E:  MOVWF  xF8
1250:  BSF    F92.5
1252:  MOVLW  00
1254:  BTFSC  F80.5
1256:  MOVLW  01
1258:  MOVWF  xF9
125A:  BSF    F93.1
125C:  MOVLW  00
125E:  BTFSC  F81.1
1260:  MOVLW  01
1262:  MOVWF  xFA
1264:  BSF    F93.0
1266:  MOVLW  00
1268:  BTFSC  F81.0
126A:  MOVLW  01
126C:  MOVWF  xFB
126E:  CLRF   xFC
1270:  MOVF   xFC,W
1272:  CALL   0452
1276:  INCF   xFC,F
1278:  MOVWF  00
127A:  CLRWDT
127C:  BTFSS  F9E.4
127E:  BRA    127A
1280:  MOVWF  FAD
1282:  MOVLW  06
1284:  SUBWF  xFC,W
1286:  BNZ   1270
1288:  MOVFF  F4,102
128C:  MOVLW  1B
128E:  MOVLB  1
1290:  MOVWF  x03
1292:  MOVLB  0
1294:  RCALL  0ED6
1296:  MOVLW  20
1298:  CLRWDT
129A:  BTFSS  F9E.4
129C:  BRA    1298
129E:  MOVWF  FAD
12A0:  MOVFF  F5,102
12A4:  MOVLW  1B
12A6:  MOVLB  1
12A8:  MOVWF  x03
12AA:  MOVLB  0
12AC:  RCALL  0ED6
12AE:  MOVLW  20
12B0:  CLRWDT
12B2:  BTFSS  F9E.4
12B4:  BRA    12B0
12B6:  MOVWF  FAD
12B8:  MOVFF  F6,102
12BC:  MOVLW  1B
12BE:  MOVLB  1
12C0:  MOVWF  x03
12C2:  MOVLB  0
12C4:  RCALL  0ED6
12C6:  MOVLW  20
12C8:  CLRWDT
12CA:  BTFSS  F9E.4
12CC:  BRA    12C8
12CE:  MOVWF  FAD
12D0:  MOVFF  F7,102
12D4:  MOVLW  1B
12D6:  MOVLB  1
12D8:  MOVWF  x03
12DA:  MOVLB  0
12DC:  RCALL  0ED6
12DE:  MOVLW  20
12E0:  CLRWDT
12E2:  BTFSS  F9E.4
12E4:  BRA    12E0
12E6:  MOVWF  FAD
12E8:  MOVFF  F8,102
12EC:  MOVLW  1B
12EE:  MOVLB  1
12F0:  MOVWF  x03
12F2:  MOVLB  0
12F4:  RCALL  0ED6
12F6:  MOVLW  20
12F8:  CLRWDT
12FA:  BTFSS  F9E.4
12FC:  BRA    12F8
12FE:  MOVWF  FAD
1300:  MOVFF  F9,102
1304:  MOVLW  1B
1306:  MOVLB  1
1308:  MOVWF  x03
130A:  MOVLB  0
130C:  RCALL  0ED6
130E:  MOVLW  20
1310:  CLRWDT
1312:  BTFSS  F9E.4
1314:  BRA    1310
1316:  MOVWF  FAD
1318:  MOVFF  FA,102
131C:  MOVLW  1B
131E:  MOVLB  1
1320:  MOVWF  x03
1322:  MOVLB  0
1324:  RCALL  0ED6
1326:  MOVLW  20
1328:  CLRWDT
132A:  BTFSS  F9E.4
132C:  BRA    1328
132E:  MOVWF  FAD
1330:  MOVFF  FB,102
1334:  MOVLW  1B
1336:  MOVLB  1
1338:  MOVWF  x03
133A:  MOVLB  0
133C:  RCALL  0ED6
133E:  BRA    121A
.................... showconsole(); 
1340:  RCALL  0DDE
.................... getc(); 
1342:  CLRWDT
1344:  BTFSS  F9E.5
1346:  BRA    1342
1348:  MOVF   FAE,W
.................... lastcommand='c'; 
134A:  MOVLW  63
134C:  MOVWF  20
.................... } 
134E:  GOTO   153C (RETURN)
....................  
.................... void console(char c) 
.................... { 
....................     
....................    int aux; 
....................    int i; 
....................   // printf("console : %c ",c); 
....................    if(c=='c')  
1352:  MOVF   xF1,W
1354:  SUBLW  63
1356:  BNZ   1360
....................    { 
....................       showconsole(); 
1358:  RCALL  0DDE
....................       lastcommand='c'; 
135A:  MOVLW  63
135C:  MOVWF  20
....................    } 
....................    else if((c=='o') && (lastcommand=='c'))  
135E:  BRA    1552
1360:  MOVF   xF1,W
1362:  SUBLW  6F
1364:  BNZ   1374
1366:  MOVF   20,W
1368:  SUBLW  63
136A:  BNZ   1374
....................    { 
....................       showoutputs(); 
136C:  BRA    0F5A
....................       lastcommand='o'; 
136E:  MOVLW  6F
1370:  MOVWF  20
....................    } 
....................    else if((c=='0'||c=='1'||c=='2'||c=='3'||c=='4'||c=='5'||c=='6'||c=='7')&& (lastcommand=='o')) 
1372:  BRA    1552
1374:  MOVF   xF1,W
1376:  SUBLW  30
1378:  BZ    13A6
137A:  MOVF   xF1,W
137C:  SUBLW  31
137E:  BZ    13A6
1380:  MOVF   xF1,W
1382:  SUBLW  32
1384:  BZ    13A6
1386:  MOVF   xF1,W
1388:  SUBLW  33
138A:  BZ    13A6
138C:  MOVF   xF1,W
138E:  SUBLW  34
1390:  BZ    13A6
1392:  MOVF   xF1,W
1394:  SUBLW  35
1396:  BZ    13A6
1398:  MOVF   xF1,W
139A:  SUBLW  36
139C:  BZ    13A6
139E:  MOVF   xF1,W
13A0:  SUBLW  37
13A2:  BTFSS  FD8.2
13A4:  BRA    151A
13A6:  MOVF   20,W
13A8:  SUBLW  6F
13AA:  BTFSS  FD8.2
13AC:  BRA    151A
....................    { 
....................       aux=relevalue; 
13AE:  MOVFF  1F,F2
....................       i=catoi(c); 
13B2:  MOVFF  F1,F4
13B6:  BRA    1104
13B8:  MOVFF  01,F3
....................  //     printf(" i=%u",i); 
....................       if(bit_test(relevalue,i)) bit_clear(aux,i); 
13BC:  MOVFF  1F,00
13C0:  MOVF   xF3,W
13C2:  MOVWF  01
13C4:  BZ    13CE
13C6:  BCF    FD8.0
13C8:  RRCF   00,F
13CA:  DECFSZ 01,F
13CC:  BRA    13C6
13CE:  BTFSS  00.0
13D0:  BRA    13EC
13D2:  MOVLW  01
13D4:  MOVWF  00
13D6:  MOVF   xF3,W
13D8:  MOVWF  01
13DA:  BZ    13E4
13DC:  BCF    FD8.0
13DE:  RLCF   00,F
13E0:  DECFSZ 01,F
13E2:  BRA    13DC
13E4:  MOVF   00,W
13E6:  XORLW  FF
13E8:  ANDWF  xF2,F
....................       else bit_set(aux,i); 
13EA:  BRA    1402
13EC:  MOVLW  01
13EE:  MOVWF  00
13F0:  MOVF   xF3,W
13F2:  MOVWF  01
13F4:  BZ    13FE
13F6:  BCF    FD8.0
13F8:  RLCF   00,F
13FA:  DECFSZ 01,F
13FC:  BRA    13F6
13FE:  MOVF   00,W
1400:  IORWF  xF2,F
....................  //     printf(" value1=%u ",aux); 
....................       write4896(aux); 
1402:  MOVFF  F2,F4
1406:  RCALL  1186
....................       printf("\r      %u %u %u %u %u %u %u %u",bit_test(relevalue,0),bit_test(relevalue,1),bit_test(relevalue,2),bit_test(relevalue,3),bit_test(relevalue,4),bit_test(relevalue,5),bit_test(relevalue,6),bit_test(relevalue,7)); 
1408:  MOVLW  00
140A:  BTFSC  1F.0
140C:  MOVLW  01
140E:  MOVWF  xF4
1410:  MOVLW  00
1412:  BTFSC  1F.1
1414:  MOVLW  01
1416:  MOVWF  xF5
1418:  MOVLW  00
141A:  BTFSC  1F.2
141C:  MOVLW  01
141E:  MOVWF  xF6
1420:  MOVLW  00
1422:  BTFSC  1F.3
1424:  MOVLW  01
1426:  MOVWF  xF7
1428:  MOVLW  00
142A:  BTFSC  1F.4
142C:  MOVLW  01
142E:  MOVWF  xF8
1430:  MOVLW  00
1432:  BTFSC  1F.5
1434:  MOVLW  01
1436:  MOVWF  xF9
1438:  MOVLW  00
143A:  BTFSC  1F.6
143C:  MOVLW  01
143E:  MOVWF  xFA
1440:  MOVLW  00
1442:  BTFSC  1F.7
1444:  MOVLW  01
1446:  MOVWF  xFB
1448:  CLRF   xFC
144A:  MOVF   xFC,W
144C:  CALL   0480
1450:  INCF   xFC,F
1452:  MOVWF  00
1454:  CLRWDT
1456:  BTFSS  F9E.4
1458:  BRA    1454
145A:  MOVWF  FAD
145C:  MOVLW  07
145E:  SUBWF  xFC,W
1460:  BNZ   144A
1462:  MOVFF  F4,102
1466:  MOVLW  1B
1468:  MOVLB  1
146A:  MOVWF  x03
146C:  MOVLB  0
146E:  RCALL  0ED6
1470:  MOVLW  20
1472:  CLRWDT
1474:  BTFSS  F9E.4
1476:  BRA    1472
1478:  MOVWF  FAD
147A:  MOVFF  F5,102
147E:  MOVLW  1B
1480:  MOVLB  1
1482:  MOVWF  x03
1484:  MOVLB  0
1486:  RCALL  0ED6
1488:  MOVLW  20
148A:  CLRWDT
148C:  BTFSS  F9E.4
148E:  BRA    148A
1490:  MOVWF  FAD
1492:  MOVFF  F6,102
1496:  MOVLW  1B
1498:  MOVLB  1
149A:  MOVWF  x03
149C:  MOVLB  0
149E:  RCALL  0ED6
14A0:  MOVLW  20
14A2:  CLRWDT
14A4:  BTFSS  F9E.4
14A6:  BRA    14A2
14A8:  MOVWF  FAD
14AA:  MOVFF  F7,102
14AE:  MOVLW  1B
14B0:  MOVLB  1
14B2:  MOVWF  x03
14B4:  MOVLB  0
14B6:  RCALL  0ED6
14B8:  MOVLW  20
14BA:  CLRWDT
14BC:  BTFSS  F9E.4
14BE:  BRA    14BA
14C0:  MOVWF  FAD
14C2:  MOVFF  F8,102
14C6:  MOVLW  1B
14C8:  MOVLB  1
14CA:  MOVWF  x03
14CC:  MOVLB  0
14CE:  RCALL  0ED6
14D0:  MOVLW  20
14D2:  CLRWDT
14D4:  BTFSS  F9E.4
14D6:  BRA    14D2
14D8:  MOVWF  FAD
14DA:  MOVFF  F9,102
14DE:  MOVLW  1B
14E0:  MOVLB  1
14E2:  MOVWF  x03
14E4:  MOVLB  0
14E6:  RCALL  0ED6
14E8:  MOVLW  20
14EA:  CLRWDT
14EC:  BTFSS  F9E.4
14EE:  BRA    14EA
14F0:  MOVWF  FAD
14F2:  MOVFF  FA,102
14F6:  MOVLW  1B
14F8:  MOVLB  1
14FA:  MOVWF  x03
14FC:  MOVLB  0
14FE:  RCALL  0ED6
1500:  MOVLW  20
1502:  CLRWDT
1504:  BTFSS  F9E.4
1506:  BRA    1502
1508:  MOVWF  FAD
150A:  MOVFF  FB,102
150E:  MOVLW  1B
1510:  MOVLB  1
1512:  MOVWF  x03
1514:  MOVLB  0
1516:  RCALL  0ED6
....................    } 
....................    else if((c=='s') && (lastcommand=='o')) 
1518:  BRA    1552
151A:  MOVF   xF1,W
151C:  SUBLW  73
151E:  BNZ   152E
1520:  MOVF   20,W
1522:  SUBLW  6F
1524:  BNZ   152E
....................    { 
....................       showconsole(); 
1526:  RCALL  0DDE
....................       lastcommand='c'; 
1528:  MOVLW  63
152A:  MOVWF  20
....................    } 
....................    else if((c=='i') && (lastcommand=='c'))  
152C:  BRA    1552
152E:  MOVF   xF1,W
1530:  SUBLW  69
1532:  BNZ   1542
1534:  MOVF   20,W
1536:  SUBLW  63
1538:  BNZ   1542
....................    { 
....................       showinputs(); 
153A:  BRA    119E
....................       lastcommand='c'; 
153C:  MOVLW  63
153E:  MOVWF  20
....................    } 
....................    else if((c=='a') && (lastcommand=='c'))  
1540:  BRA    1552
1542:  MOVF   xF1,W
1544:  SUBLW  61
1546:  BNZ   1552
1548:  MOVF   20,W
154A:  SUBLW  63
154C:  BNZ   1552
....................    { 
....................       lastcommand='a'; 
154E:  MOVLW  61
1550:  MOVWF  20
....................    } 
....................     
.................... } 
1552:  GOTO   1566 (RETURN)
....................  
.................... int x; 
.................... int1 remote; 
.................... void canTransmit ( ); 
.................... int ADRESS; 
.................... int1 can_push (int32 tx_id, int8 * tx_buffer, int8 tx_length, int8 tx_priority, int1 tx_extendedID, int1 tx_emptyframe); 
.................... #include "C:\DomoticaNovo\Estores\ProgramaPIC\switch_decision.c" 
.................... #define Push_b 0 
.................... #define Switch_ 1 
....................  
.................... int out_value; 
.................... int switch_value; 
.................... int switch_modes; 
.................... int what_control_what[8]; 
....................  
.................... int decisor(int1 curr_out_value,int1 curr_swit_value,int1 last_swit_value,int1 mode) 
.................... {     
....................     
....................    if(mode==Push_b) 
*
36D8:  MOVF   xD3,F
36DA:  BNZ   36F0
....................    { 
....................       if(curr_swit_value) return 1; 
36DC:  MOVF   xD1,F
36DE:  BZ    36E8
36E0:  MOVLW  01
36E2:  MOVWF  01
36E4:  BRA    3716
....................       else return 0; 
36E6:  BRA    36EE
36E8:  MOVLW  00
36EA:  MOVWF  01
36EC:  BRA    3716
....................    } 
....................    else if (mode==Switch_) 
36EE:  BRA    3716
36F0:  DECFSZ xD3,W
36F2:  BRA    3716
....................    { 
....................       if((curr_swit_value==1) && (last_swit_value==0))  
36F4:  DECFSZ xD1,W
36F6:  BRA    3710
36F8:  MOVF   xD2,F
36FA:  BNZ   3710
....................       { 
....................          if(curr_out_value) return 0; 
36FC:  MOVF   xD0,F
36FE:  BZ    3708
3700:  MOVLW  00
3702:  MOVWF  01
3704:  BRA    3716
....................          else  
3706:  BRA    370E
....................          { 
....................          return 1; //e pus aki 
3708:  MOVLW  01
370A:  MOVWF  01
370C:  BRA    3716
....................          } 
....................          //return 1; tirei daki 
....................       } 
....................      else return 2; 
370E:  BRA    3716
3710:  MOVLW  02
3712:  MOVWF  01
3714:  BRA    3716
....................    } 
.................... } 
3716:  GOTO   3812 (RETURN)
....................  
.................... void output_refresh() 
.................... { 
.................... int oaux1,oaux2,out; 
.................... int old_switch,oau; 
.................... int buffer[6]; 
....................     
....................    old_switch=switch_value; 
371A:  MOVFF  25,C4
....................    switch_value=0; 
371E:  CLRF   25
....................    out=out_value; 
3720:  MOVFF  24,C3
....................    if(!input(inte0)) bit_set(switch_value,0); 
3724:  BSF    F92.0
3726:  BTFSS  F80.0
3728:  BSF    25.0
....................    if(!input(inte1)) bit_set(switch_value,1); 
372A:  BSF    F92.1
372C:  BTFSS  F80.1
372E:  BSF    25.1
....................    if(!input(inte2)) bit_set(switch_value,2); 
3730:  BSF    F92.2
3732:  BTFSS  F80.2
3734:  BSF    25.2
....................    if(!input(inte3)) bit_set(switch_value,3); 
3736:  BSF    F92.3
3738:  BTFSS  F80.3
373A:  BSF    25.3
....................    if(!input(inte4)) bit_set(switch_value,4); 
373C:  BSF    F92.4
373E:  BTFSS  F80.4
3740:  BSF    25.4
....................    if(!input(inte5)) bit_set(switch_value,5); 
3742:  BSF    F92.5
3744:  BTFSS  F80.5
3746:  BSF    25.5
....................    if(!input(inte6)) bit_set(switch_value,6); 
3748:  BSF    F93.1
374A:  BTFSS  F81.1
374C:  BSF    25.6
....................    if(!input(inte7)) bit_set(switch_value,7); 
374E:  BSF    F93.0
3750:  BTFSS  F81.0
3752:  BSF    25.7
....................    if(switch_value!=0) remote=0; 
3754:  MOVF   25,F
3756:  BTFSS  FD8.2
3758:  BCF    22.0
....................    if (remote==1) return; 
375A:  BTFSS  22.0
375C:  BRA    3760
375E:  BRA    38DC
....................    for (oaux1=0;oaux1<8;++oaux1) 
3760:  CLRF   xC1
3762:  MOVF   xC1,W
3764:  SUBLW  07
3766:  BTFSS  FD8.0
3768:  BRA    3856
....................    {    
....................          for (oaux2=0;oaux2<8;++oaux2) 
376A:  CLRF   xC2
376C:  MOVF   xC2,W
376E:  SUBLW  07
3770:  BTFSS  FD8.0
3772:  BRA    3852
....................          {   
....................             if(bit_test(what_control_what[oaux1],oaux2)) 
3774:  CLRF   03
3776:  MOVF   xC1,W
3778:  ADDLW  27
377A:  MOVWF  FE9
377C:  MOVLW  00
377E:  ADDWFC 03,W
3780:  MOVWF  FEA
3782:  MOVFF  FEF,CC
3786:  MOVFF  CC,00
378A:  MOVF   xC2,W
378C:  MOVWF  01
378E:  BZ    3798
3790:  BCF    FD8.0
3792:  RRCF   00,F
3794:  DECFSZ 01,F
3796:  BRA    3790
3798:  BTFSS  00.0
379A:  BRA    384E
....................             { 
....................                oau=decisor(bit_test(out_value,oaux2),bit_test(switch_value,oaux1) ,bit_test(old_switch,oaux1),bit_test(switch_modes,oaux1)); 
379C:  MOVFF  24,00
37A0:  MOVF   xC2,W
37A2:  MOVWF  01
37A4:  BZ    37AE
37A6:  BCF    FD8.0
37A8:  RRCF   00,F
37AA:  DECFSZ 01,F
37AC:  BRA    37A6
37AE:  MOVLW  00
37B0:  BTFSC  00.0
37B2:  MOVLW  01
37B4:  MOVWF  xCC
37B6:  MOVFF  25,00
37BA:  MOVF   xC1,W
37BC:  MOVWF  01
37BE:  BZ    37C8
37C0:  BCF    FD8.0
37C2:  RRCF   00,F
37C4:  DECFSZ 01,F
37C6:  BRA    37C0
37C8:  MOVLW  00
37CA:  BTFSC  00.0
37CC:  MOVLW  01
37CE:  MOVWF  xCD
37D0:  MOVFF  C4,00
37D4:  MOVF   xC1,W
37D6:  MOVWF  01
37D8:  BZ    37E2
37DA:  BCF    FD8.0
37DC:  RRCF   00,F
37DE:  DECFSZ 01,F
37E0:  BRA    37DA
37E2:  MOVLW  00
37E4:  BTFSC  00.0
37E6:  MOVLW  01
37E8:  MOVWF  xCE
37EA:  MOVFF  26,00
37EE:  MOVF   xC1,W
37F0:  MOVWF  01
37F2:  BZ    37FC
37F4:  BCF    FD8.0
37F6:  RRCF   00,F
37F8:  DECFSZ 01,F
37FA:  BRA    37F4
37FC:  MOVLW  00
37FE:  BTFSC  00.0
3800:  MOVLW  01
3802:  MOVFF  CC,D0
3806:  MOVFF  CD,D1
380A:  MOVFF  CE,D2
380E:  MOVWF  xD3
3810:  BRA    36D8
3812:  MOVFF  01,C5
....................                if(oau==1) bit_set(out,oaux2); 
3816:  DECFSZ xC5,W
3818:  BRA    3832
381A:  MOVLW  01
381C:  MOVWF  00
381E:  MOVF   xC2,W
3820:  MOVWF  01
3822:  BZ    382C
3824:  BCF    FD8.0
3826:  RLCF   00,F
3828:  DECFSZ 01,F
382A:  BRA    3824
382C:  MOVF   00,W
382E:  IORWF  xC3,F
....................                else if (oau==0) bit_clear(out,oaux2); 
3830:  BRA    384E
3832:  MOVF   xC5,F
3834:  BNZ   384E
3836:  MOVLW  01
3838:  MOVWF  00
383A:  MOVF   xC2,W
383C:  MOVWF  01
383E:  BZ    3848
3840:  BCF    FD8.0
3842:  RLCF   00,F
3844:  DECFSZ 01,F
3846:  BRA    3840
3848:  MOVF   00,W
384A:  XORLW  FF
384C:  ANDWF  xC3,F
....................                
....................             } 
....................          } 
384E:  INCF   xC2,F
3850:  BRA    376C
....................    } 
3852:  INCF   xC1,F
3854:  BRA    3762
....................    for(oaux1=0;oaux1<8;++oaux1) 
3856:  CLRF   xC1
3858:  MOVF   xC1,W
385A:  SUBLW  07
385C:  BNC   38D8
....................    {   
....................       if(bit_test(out,oaux1)!=bit_test(out_value,oaux1)) 
385E:  MOVFF  C3,00
3862:  MOVF   xC1,W
3864:  MOVWF  01
3866:  BZ    3870
3868:  BCF    FD8.0
386A:  RRCF   00,F
386C:  DECFSZ 01,F
386E:  BRA    3868
3870:  MOVLW  00
3872:  BTFSC  00.0
3874:  MOVLW  01
3876:  MOVWF  xCC
3878:  MOVFF  24,00
387C:  MOVF   xC1,W
387E:  MOVWF  01
3880:  BZ    388A
3882:  BCF    FD8.0
3884:  RRCF   00,F
3886:  DECFSZ 01,F
3888:  BRA    3882
388A:  MOVLW  00
388C:  BTFSC  00.0
388E:  MOVLW  01
3890:  SUBWF  xCC,W
3892:  BZ    38D4
....................       { 
....................          buffer[0]=0; 
3894:  CLRF   xC6
....................          buffer[1]=ADRESS; 
3896:  MOVFF  23,C7
....................          buffer[2]=oaux1; 
389A:  MOVFF  C1,C8
....................          buffer[3]=13;//man value change 
389E:  MOVLW  0D
38A0:  MOVWF  xC9
....................          buffer[4]= bit_test(out,oaux1); 
38A2:  MOVFF  C3,00
38A6:  MOVF   xC1,W
38A8:  MOVWF  01
38AA:  BZ    38B4
38AC:  BCF    FD8.0
38AE:  RRCF   00,F
38B0:  DECFSZ 01,F
38B2:  BRA    38AC
38B4:  CLRF   xCA
38B6:  BTFSC  00.0
38B8:  INCF   xCA,F
....................          can_push(0,buffer,5,0,false,false); 
38BA:  CLRF   xDA
38BC:  CLRF   xD9
38BE:  CLRF   xD8
38C0:  CLRF   xD7
38C2:  CLRF   xDC
38C4:  MOVLW  C6
38C6:  MOVWF  xDB
38C8:  MOVLW  05
38CA:  MOVWF  xDD
38CC:  CLRF   xDE
38CE:  CLRF   xDF
38D0:  CLRF   xE0
38D2:  RCALL  32AE
....................       } 
....................    } 
38D4:  INCF   xC1,F
38D6:  BRA    3858
....................    out_value=out; 
38D8:  MOVFF  C3,24
.................... } 
38DC:  GOTO   3F86 (RETURN)
....................     
....................  
....................  
.................... #define EADRESS 4 
.................... #define DEV_ID 0 
....................  
.................... #include "C:\DomoticaNovo\Estores\ProgramaPIC\can_proc.c" 
.................... //TIPOS 
.................... #define Set_Value 1 
.................... #define Get_Value 2 
.................... #define Value_Ans 3 
.................... #define Ping_Request 4 
.................... #define Ping_Ans 5 
.................... #define Set_Configuration 6  
.................... #define Get_Configuration 7 
.................... #define Configuration_Ans 8 
.................... #define Reset 9 
.................... #define Direct_Adress 10 
.................... #define Indirect_adress_config 11 
.................... #define Indirect_Set_Value 12 
.................... #define man_val_change 13 
.................... #define newadr 14 
.................... #define Set_virtual_int 15 
.................... #define Get_virtual_int 16 
.................... #define Virtual_int_Ans 17 
.................... #define Set_glob_adr    18 
.................... #define Get_glob_adr    19 
.................... #define glob_adr_ans    20 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
....................  
.................... //set configuration 
.................... /* 
.................... para este device 
....................  
.................... EEPROM adr funcao 
.................... 10          what_control_what[0] 
.................... 11          what_control_what[1] para cada interruptor diz quais os reles k sao controlados 
.................... 12          what_control_what[2] 
.................... .           . 
.................... .           . 
.................... 17          what_control_what[7] 
.................... 20          switch_modes   diz se qd se carrega no int liga ao carregar e desliga ao tirar ou se vai comutando 
.................... */ 
....................  
.................... int16 conv_adr(int adr) 
.................... { 
....................    return MAKE16((adr >>5) & 0x07,(adr << 3) & 0xF8); 
*
3282:  SWAPF  xD5,W
3284:  MOVWF  00
3286:  RRCF   00,F
3288:  MOVLW  07
328A:  ANDWF  00,F
328C:  MOVF   00,W
328E:  ANDLW  07
3290:  MOVWF  xD7
3292:  RLCF   xD5,W
3294:  MOVWF  00
3296:  RLCF   00,F
3298:  RLCF   00,F
329A:  MOVLW  F8
329C:  ANDWF  00,F
329E:  MOVF   00,W
32A0:  ANDLW  F8
32A2:  MOVFF  D7,03
32A6:  MOVWF  01
32A8:  MOVFF  D7,02
.................... } 
32AC:  RETLW  00
.................... void proc_can(int32 id,*buffer,int len){ 
.................... int dest_sub_adr, send_adr,send_subadr, type,data0,data1; 
.................... int tbuffer[7]; 
.................... dest_sub_adr=buffer[0]; 
*
33E8:  MOVF   xC5,W
33EA:  MOVWF  FE9
33EC:  MOVFF  C6,FEA
33F0:  MOVFF  FEF,C8
.................... send_adr=buffer[1]; 
33F4:  MOVLW  01
33F6:  ADDWF  xC5,W
33F8:  MOVWF  FE9
33FA:  MOVLW  00
33FC:  ADDWFC xC6,W
33FE:  MOVWF  FEA
3400:  MOVFF  FEF,C9
.................... send_subadr=buffer[2]; 
3404:  MOVLW  02
3406:  ADDWF  xC5,W
3408:  MOVWF  FE9
340A:  MOVLW  00
340C:  ADDWFC xC6,W
340E:  MOVWF  FEA
3410:  MOVFF  FEF,CA
.................... type=buffer[3]; 
3414:  MOVLW  03
3416:  ADDWF  xC5,W
3418:  MOVWF  FE9
341A:  MOVLW  00
341C:  ADDWFC xC6,W
341E:  MOVWF  FEA
3420:  MOVFF  FEF,CB
.................... data0=buffer[4]; 
3424:  MOVLW  04
3426:  ADDWF  xC5,W
3428:  MOVWF  FE9
342A:  MOVLW  00
342C:  ADDWFC xC6,W
342E:  MOVWF  FEA
3430:  MOVFF  FEF,CC
.................... data1=buffer[5]; 
3434:  MOVLW  05
3436:  ADDWF  xC5,W
3438:  MOVWF  FE9
343A:  MOVLW  00
343C:  ADDWFC xC6,W
343E:  MOVWF  FEA
3440:  MOVFF  FEF,CD
.................... printf("Tipo=%X Dado1=%X Dado2=%X\n\r",type,data0,data1); 
3444:  CLRF   xD5
3446:  MOVF   xD5,W
3448:  CALL   04B0
344C:  INCF   xD5,F
344E:  MOVWF  00
3450:  CLRWDT
3452:  BTFSS  F9E.4
3454:  BRA    3450
3456:  MOVWF  FAD
3458:  MOVLW  05
345A:  SUBWF  xD5,W
345C:  BNZ   3446
345E:  CLRF   18
3460:  BTFSC  FF2.7
3462:  BSF    18.7
3464:  BCF    FF2.7
3466:  MOVFF  CB,102
346A:  MOVLW  37
346C:  MOVLB  1
346E:  MOVWF  x03
3470:  MOVLB  0
3472:  CALL   1B04
3476:  BTFSC  18.7
3478:  BSF    FF2.7
347A:  MOVLW  07
347C:  MOVWF  xD6
347E:  MOVF   xD6,W
3480:  CALL   04B0
3484:  INCF   xD6,F
3486:  MOVWF  00
3488:  CLRWDT
348A:  BTFSS  F9E.4
348C:  BRA    3488
348E:  MOVWF  FAD
3490:  MOVLW  0E
3492:  SUBWF  xD6,W
3494:  BNZ   347E
3496:  CLRF   18
3498:  BTFSC  FF2.7
349A:  BSF    18.7
349C:  BCF    FF2.7
349E:  MOVFF  CC,102
34A2:  MOVLW  37
34A4:  MOVLB  1
34A6:  MOVWF  x03
34A8:  MOVLB  0
34AA:  CALL   1B04
34AE:  BTFSC  18.7
34B0:  BSF    FF2.7
34B2:  MOVLW  10
34B4:  MOVWF  xD7
34B6:  MOVF   xD7,W
34B8:  CALL   04B0
34BC:  INCF   xD7,F
34BE:  MOVWF  00
34C0:  CLRWDT
34C2:  BTFSS  F9E.4
34C4:  BRA    34C0
34C6:  MOVWF  FAD
34C8:  MOVLW  17
34CA:  SUBWF  xD7,W
34CC:  BNZ   34B6
34CE:  CLRF   18
34D0:  BTFSC  FF2.7
34D2:  BSF    18.7
34D4:  BCF    FF2.7
34D6:  MOVFF  CD,102
34DA:  MOVLW  37
34DC:  MOVLB  1
34DE:  MOVWF  x03
34E0:  MOVLB  0
34E2:  CALL   1B04
34E6:  BTFSC  18.7
34E8:  BSF    FF2.7
34EA:  MOVLW  0A
34EC:  CLRWDT
34EE:  BTFSS  F9E.4
34F0:  BRA    34EC
34F2:  MOVWF  FAD
34F4:  MOVLW  0D
34F6:  CLRWDT
34F8:  BTFSS  F9E.4
34FA:  BRA    34F6
34FC:  MOVWF  FAD
.................... switch(type) 
.................... { 
34FE:  MOVLW  01
3500:  SUBWF  xCB,W
3502:  ADDLW  F2
3504:  BTFSC  FD8.0
3506:  BRA    3694
3508:  ADDLW  0E
350A:  GOTO   3698
....................    case Set_Value: 
....................       remote=1; 
350E:  BSF    22.0
....................       if (data0==0) bit_clear(out_value,dest_sub_adr); 
3510:  MOVF   xCC,F
3512:  BNZ   352E
3514:  MOVLW  01
3516:  MOVWF  00
3518:  MOVF   xC8,W
351A:  MOVWF  01
351C:  BZ    3526
351E:  BCF    FD8.0
3520:  RLCF   00,F
3522:  DECFSZ 01,F
3524:  BRA    351E
3526:  MOVF   00,W
3528:  XORLW  FF
352A:  ANDWF  24,F
....................       else bit_set(out_value,dest_sub_adr); 
352C:  BRA    3544
352E:  MOVLW  01
3530:  MOVWF  00
3532:  MOVF   xC8,W
3534:  MOVWF  01
3536:  BZ    3540
3538:  BCF    FD8.0
353A:  RLCF   00,F
353C:  DECFSZ 01,F
353E:  BRA    3538
3540:  MOVF   00,W
3542:  IORWF  24,F
....................    break; 
3544:  BRA    3694
....................     
....................    case Get_Value: 
....................       tbuffer[0]=send_subadr; 
3546:  MOVFF  CA,CE
....................       tbuffer[1]=ADRESS; 
354A:  MOVFF  23,CF
....................       tbuffer[2]=dest_sub_adr; 
354E:  MOVFF  C8,D0
....................       tbuffer[3]=Value_Ans; 
3552:  MOVLW  03
3554:  MOVWF  xD1
....................       tbuffer[4]=bit_test(out_value,dest_sub_adr); 
3556:  MOVFF  24,00
355A:  MOVF   xC8,W
355C:  MOVWF  01
355E:  BZ    3568
3560:  BCF    FD8.0
3562:  RRCF   00,F
3564:  DECFSZ 01,F
3566:  BRA    3560
3568:  CLRF   xD2
356A:  BTFSC  00.0
356C:  INCF   xD2,F
....................       can_push(conv_adr(send_adr),tbuffer,5,0,false,false); 
356E:  MOVFF  C9,D5
3572:  RCALL  3282
3574:  MOVFF  02,D6
3578:  MOVFF  01,D5
357C:  CLRF   xDA
357E:  CLRF   xD9
3580:  MOVFF  02,D8
3584:  MOVFF  01,D7
3588:  CLRF   xDC
358A:  MOVLW  CE
358C:  MOVWF  xDB
358E:  MOVLW  05
3590:  MOVWF  xDD
3592:  CLRF   xDE
3594:  CLRF   xDF
3596:  CLRF   xE0
3598:  RCALL  32AE
....................    break; 
359A:  BRA    3694
....................     
....................    case Ping_Request: 
....................       tbuffer[0]=send_subadr; 
359C:  MOVFF  CA,CE
....................       tbuffer[1]=ADRESS; 
35A0:  MOVFF  23,CF
....................       tbuffer[2]=dest_sub_adr; 
35A4:  MOVFF  C8,D0
....................       tbuffer[3]=Ping_Ans; 
35A8:  MOVLW  05
35AA:  MOVWF  xD1
....................       can_push(conv_adr(send_adr),tbuffer,4,0,false,false); 
35AC:  MOVFF  C9,D5
35B0:  RCALL  3282
35B2:  MOVFF  02,D6
35B6:  MOVFF  01,D5
35BA:  CLRF   xDA
35BC:  CLRF   xD9
35BE:  MOVFF  02,D8
35C2:  MOVFF  01,D7
35C6:  CLRF   xDC
35C8:  MOVLW  CE
35CA:  MOVWF  xDB
35CC:  MOVLW  04
35CE:  MOVWF  xDD
35D0:  CLRF   xDE
35D2:  CLRF   xDF
35D4:  CLRF   xE0
35D6:  RCALL  32AE
....................    break; 
35D8:  BRA    3694
....................  
....................    case reset: 
....................       reset_cpu(); 
35DA:  RESET
....................    break; 
35DC:  BRA    3694
....................     
....................    case Set_Configuration: 
....................       write_eeprom(data0,data1); 
35DE:  MOVFF  CC,FA9
35E2:  MOVFF  CD,FA8
35E6:  BCF    FA6.6
35E8:  BCF    FA6.7
35EA:  BSF    FA6.2
35EC:  MOVFF  FF2,00
35F0:  BCF    FF2.7
35F2:  MOVLB  F
35F4:  MOVLW  55
35F6:  MOVWF  FA7
35F8:  MOVLW  AA
35FA:  MOVWF  FA7
35FC:  BSF    FA6.1
35FE:  BTFSC  FA6.1
3600:  BRA    35FE
3602:  BCF    FA6.2
3604:  MOVF   00,W
3606:  IORWF  FF2,F
....................    break; 
3608:  MOVLB  0
360A:  BRA    3694
....................    case Get_Configuration: 
....................       tbuffer[0]=send_subadr; 
360C:  MOVFF  CA,CE
....................       tbuffer[1]=ADRESS; 
3610:  MOVFF  23,CF
....................       tbuffer[2]=dest_sub_adr; 
3614:  MOVFF  C8,D0
....................       tbuffer[3]=Configuration_Ans; 
3618:  MOVLW  08
361A:  MOVWF  xD1
....................       tbuffer[4]=data0; 
361C:  MOVFF  CC,D2
....................       tbuffer[5]= read_eeprom(data0); 
3620:  MOVFF  FF2,D5
3624:  BCF    FF2.7
3626:  MOVFF  CC,FA9
362A:  BCF    FA6.6
362C:  BCF    FA6.7
362E:  BSF    FA6.0
3630:  MOVF   FA8,W
3632:  BTFSC  xD5.7
3634:  BSF    FF2.7
3636:  MOVWF  xD3
....................       can_push(conv_adr(send_adr),tbuffer,6,0,false,false); 
3638:  MOVFF  C9,D5
363C:  RCALL  3282
363E:  MOVFF  02,D6
3642:  MOVFF  01,D5
3646:  CLRF   xDA
3648:  CLRF   xD9
364A:  MOVFF  02,D8
364E:  MOVFF  01,D7
3652:  CLRF   xDC
3654:  MOVLW  CE
3656:  MOVWF  xDB
3658:  MOVLW  06
365A:  MOVWF  xDD
365C:  CLRF   xDE
365E:  CLRF   xDF
3660:  CLRF   xE0
3662:  RCALL  32AE
....................    break; 
3664:  BRA    3694
....................     
....................    case newadr: 
....................       write_eeprom(EADRESS,data0); 
3666:  MOVLW  04
3668:  MOVWF  FA9
366A:  MOVFF  CC,FA8
366E:  BCF    FA6.6
3670:  BCF    FA6.7
3672:  BSF    FA6.2
3674:  MOVFF  FF2,00
3678:  BCF    FF2.7
367A:  MOVLB  F
367C:  MOVLW  55
367E:  MOVWF  FA7
3680:  MOVLW  AA
3682:  MOVWF  FA7
3684:  BSF    FA6.1
3686:  BTFSC  FA6.1
3688:  BRA    3686
368A:  BCF    FA6.2
368C:  MOVF   00,W
368E:  IORWF  FF2,F
....................    break; 
3690:  MOVLB  0
3692:  BRA    3694
.................... } 
.................... } 
3694:  GOTO   3F80 (RETURN)
.................... void pong(void) 
.................... { 
.................... int data[4]={13,14,1}; 
.................... data[3]=++x; 
.................... can_push(0,data,4,3,FALSE,FALSE);    
.................... } 
....................  
....................  
....................  
....................  
.................... //EEPROM Adress definitions 
....................  #define EBRP 7 
....................  #define ESEG2PHTS 5 
....................  #define ESJW 6 
....................  #define EPHSEG1 1 
....................  #define EPHSEG2 2 
....................  #define EPRSEG 3 
....................  
....................  //DEBUG MODES 
....................   
....................  #define NODEBUG 0 
....................  #define D_RS232 1 
....................  #define DCAN 2 
.................... #include "C:\DomoticaNovo\Estores\ProgramaPIC\configure.c" 
....................  
....................  
.................... void configure() 
.................... { 
.................... while (true) 
.................... { 
....................    char string[30]; 
....................    char cc; 
....................    int ci,ci2; 
....................    printf("\n\r"); 
*
25A4:  MOVLW  0A
25A6:  CLRWDT
25A8:  BTFSS  F9E.4
25AA:  BRA    25A6
25AC:  MOVWF  FAD
25AE:  MOVLW  0D
25B0:  CLRWDT
25B2:  BTFSS  F9E.4
25B4:  BRA    25B0
25B6:  MOVWF  FAD
....................    printf("*****************************\n\r"); 
25B8:  CLRF   xE2
25BA:  MOVF   xE2,W
25BC:  CALL   03B8
25C0:  INCF   xE2,F
25C2:  MOVWF  00
25C4:  CLRWDT
25C6:  BTFSS  F9E.4
25C8:  BRA    25C4
25CA:  MOVWF  FAD
25CC:  MOVLW  1F
25CE:  SUBWF  xE2,W
25D0:  BNZ   25BA
....................    printf("* A-Configure Module Adress *\n\r"); 
25D2:  CLRF   xE2
25D4:  MOVF   xE2,W
25D6:  CALL   04E6
25DA:  INCF   xE2,F
25DC:  MOVWF  00
25DE:  CLRWDT
25E0:  BTFSS  F9E.4
25E2:  BRA    25DE
25E4:  MOVWF  FAD
25E6:  MOVLW  1F
25E8:  SUBWF  xE2,W
25EA:  BNZ   25D4
....................    printf("* C-Configure Can           *\n\r"); 
25EC:  CLRF   xE2
25EE:  MOVF   xE2,W
25F0:  CALL   0520
25F4:  INCF   xE2,F
25F6:  MOVWF  00
25F8:  CLRWDT
25FA:  BTFSS  F9E.4
25FC:  BRA    25F8
25FE:  MOVWF  FAD
2600:  MOVLW  1F
2602:  SUBWF  xE2,W
2604:  BNZ   25EE
....................    printf("* Q-Quit and Reset          *\n\r"); 
2606:  CLRF   xE2
2608:  MOVF   xE2,W
260A:  CALL   055A
260E:  INCF   xE2,F
2610:  MOVWF  00
2612:  CLRWDT
2614:  BTFSS  F9E.4
2616:  BRA    2612
2618:  MOVWF  FAD
261A:  MOVLW  1F
261C:  SUBWF  xE2,W
261E:  BNZ   2608
....................    printf("* W-Write EEPROM            *\n\r"); 
2620:  CLRF   xE2
2622:  MOVF   xE2,W
2624:  CALL   0594
2628:  INCF   xE2,F
262A:  MOVWF  00
262C:  CLRWDT
262E:  BTFSS  F9E.4
2630:  BRA    262C
2632:  MOVWF  FAD
2634:  MOVLW  1F
2636:  SUBWF  xE2,W
2638:  BNZ   2622
....................    printf("* R-Read EEPROM             *\n\r"); 
263A:  CLRF   xE2
263C:  MOVF   xE2,W
263E:  CALL   05CE
2642:  INCF   xE2,F
2644:  MOVWF  00
2646:  CLRWDT
2648:  BTFSS  F9E.4
264A:  BRA    2646
264C:  MOVWF  FAD
264E:  MOVLW  1F
2650:  SUBWF  xE2,W
2652:  BNZ   263C
....................    printf("*****************************\n\r"); 
2654:  CLRF   xE2
2656:  MOVF   xE2,W
2658:  CALL   03B8
265C:  INCF   xE2,F
265E:  MOVWF  00
2660:  CLRWDT
2662:  BTFSS  F9E.4
2664:  BRA    2660
2666:  MOVWF  FAD
2668:  MOVLW  1F
266A:  SUBWF  xE2,W
266C:  BNZ   2656
....................     
....................    while(!kbhit()){} 
266E:  BTFSC  F9E.5
2670:  BRA    2674
2672:  BRA    266E
....................    cc=getc(); 
2674:  CLRWDT
2676:  BTFSS  F9E.5
2678:  BRA    2674
267A:  MOVFF  FAE,DF
....................    if (cc=='a') 
267E:  MOVF   xDF,W
2680:  SUBLW  61
2682:  BTFSS  FD8.2
2684:  BRA    27DE
....................    { 
....................    printf("**********************\n\r"); 
2686:  CLRF   xE2
2688:  MOVF   xE2,W
268A:  CALL   01D6
268E:  INCF   xE2,F
2690:  MOVWF  00
2692:  CLRWDT
2694:  BTFSS  F9E.4
2696:  BRA    2692
2698:  MOVWF  FAD
269A:  MOVLW  18
269C:  SUBWF  xE2,W
269E:  BNZ   2688
....................    printf("* Current adress=%u  *\n\r",read_eeprom(EADRESS)); 
26A0:  MOVFF  FF2,E2
26A4:  BCF    FF2.7
26A6:  MOVLW  04
26A8:  MOVWF  FA9
26AA:  BCF    FA6.6
26AC:  BCF    FA6.7
26AE:  BSF    FA6.0
26B0:  MOVF   FA8,W
26B2:  BTFSC  xE2.7
26B4:  BSF    FF2.7
26B6:  MOVWF  xE3
26B8:  CLRF   xE4
26BA:  MOVF   xE4,W
26BC:  CALL   0608
26C0:  INCF   xE4,F
26C2:  MOVWF  00
26C4:  MOVF   00,W
26C6:  CLRWDT
26C8:  BTFSS  F9E.4
26CA:  BRA    26C6
26CC:  MOVWF  FAD
26CE:  MOVLW  11
26D0:  SUBWF  xE4,W
26D2:  BNZ   26BA
26D4:  CLRF   18
26D6:  BTFSC  FF2.7
26D8:  BSF    18.7
26DA:  BCF    FF2.7
26DC:  MOVFF  E3,102
26E0:  MOVLW  1B
26E2:  MOVLB  1
26E4:  MOVWF  x03
26E6:  MOVLB  0
26E8:  CALL   0ED6
26EC:  BTFSC  18.7
26EE:  BSF    FF2.7
26F0:  MOVLW  13
26F2:  MOVWF  xE5
26F4:  MOVF   xE5,W
26F6:  CALL   0608
26FA:  INCF   xE5,F
26FC:  MOVWF  00
26FE:  MOVF   00,W
2700:  CLRWDT
2702:  BTFSS  F9E.4
2704:  BRA    2700
2706:  MOVWF  FAD
2708:  MOVLW  18
270A:  SUBWF  xE5,W
270C:  BNZ   26F4
....................    printf("**********************\n\r\n\r"); 
270E:  CLRF   xE2
2710:  MOVF   xE2,W
2712:  CALL   063C
2716:  INCF   xE2,F
2718:  MOVWF  00
271A:  CLRWDT
271C:  BTFSS  F9E.4
271E:  BRA    271A
2720:  MOVWF  FAD
2722:  MOVLW  1A
2724:  SUBWF  xE2,W
2726:  BNZ   2710
....................    printf("New Adress:"); 
2728:  CLRF   xE2
272A:  MOVF   xE2,W
272C:  CALL   0672
2730:  INCF   xE2,F
2732:  MOVWF  00
2734:  CLRWDT
2736:  BTFSS  F9E.4
2738:  BRA    2734
273A:  MOVWF  FAD
273C:  MOVLW  0B
273E:  SUBWF  xE2,W
2740:  BNZ   272A
....................    gets(string); 
2742:  CLRF   FEA
2744:  MOVLW  C1
2746:  MOVWF  FE9
2748:  DECF   FE9,F
274A:  INCF   FE9,F
274C:  CLRWDT
274E:  BTFSS  F9E.5
2750:  BRA    274C
2752:  MOVFF  FAE,FEF
2756:  MOVLW  0D
2758:  SUBWF  FEF,W
275A:  BNZ   274A
275C:  CLRF   FEF
....................    ci=atoi(string); 
275E:  CLRF   xE4
2760:  MOVLW  C1
2762:  MOVWF  xE3
2764:  RCALL  240A
2766:  MOVFF  01,E0
....................    printf("\n\r Gravar? Y/N \n\r"); 
276A:  CLRF   xE2
276C:  MOVF   xE2,W
276E:  CALL   0698
2772:  INCF   xE2,F
2774:  MOVWF  00
2776:  CLRWDT
2778:  BTFSS  F9E.4
277A:  BRA    2776
277C:  MOVWF  FAD
277E:  MOVLW  11
2780:  SUBWF  xE2,W
2782:  BNZ   276C
....................    gets(string); 
2784:  CLRF   FEA
2786:  MOVLW  C1
2788:  MOVWF  FE9
278A:  DECF   FE9,F
278C:  INCF   FE9,F
278E:  CLRWDT
2790:  BTFSS  F9E.5
2792:  BRA    278E
2794:  MOVFF  FAE,FEF
2798:  MOVLW  0D
279A:  SUBWF  FEF,W
279C:  BNZ   278C
279E:  CLRF   FEF
....................    if (string=="y") write_eeprom(EADRESS,ci); 
27A0:  MOVLW  0D
27A2:  MOVWF  03
27A4:  MOVLW  CE
27A6:  SUBLW  C1
27A8:  BNZ   27DA
27AA:  MOVF   03,F
27AC:  BNZ   27DA
27AE:  MOVLW  04
27B0:  MOVWF  FA9
27B2:  MOVFF  E0,FA8
27B6:  BCF    FA6.6
27B8:  BCF    FA6.7
27BA:  BSF    FA6.2
27BC:  MOVFF  FF2,00
27C0:  BCF    FF2.7
27C2:  MOVLB  F
27C4:  MOVLW  55
27C6:  MOVWF  FA7
27C8:  MOVLW  AA
27CA:  MOVWF  FA7
27CC:  BSF    FA6.1
27CE:  BTFSC  FA6.1
27D0:  BRA    27CE
27D2:  BCF    FA6.2
27D4:  MOVF   00,W
27D6:  IORWF  FF2,F
27D8:  MOVLB  0
....................    } 
....................    else if (cc=='r')  
27DA:  GOTO   30D0
27DE:  MOVF   xDF,W
27E0:  SUBLW  72
27E2:  BTFSS  FD8.2
27E4:  BRA    28D6
....................    { 
....................       printf("Endereco a ler?:"); 
27E6:  CLRF   xE2
27E8:  MOVF   xE2,W
27EA:  CALL   06C4
27EE:  INCF   xE2,F
27F0:  MOVWF  00
27F2:  CLRWDT
27F4:  BTFSS  F9E.4
27F6:  BRA    27F2
27F8:  MOVWF  FAD
27FA:  MOVLW  10
27FC:  SUBWF  xE2,W
27FE:  BNZ   27E8
....................       gets(string); 
2800:  CLRF   FEA
2802:  MOVLW  C1
2804:  MOVWF  FE9
2806:  DECF   FE9,F
2808:  INCF   FE9,F
280A:  CLRWDT
280C:  BTFSS  F9E.5
280E:  BRA    280A
2810:  MOVFF  FAE,FEF
2814:  MOVLW  0D
2816:  SUBWF  FEF,W
2818:  BNZ   2808
281A:  CLRF   FEF
....................       printf("Endereco 0x%X=0x%X\n\r",atoi(string),read_eeprom(atoi(string))); 
281C:  CLRF   xE4
281E:  MOVLW  C1
2820:  MOVWF  xE3
2822:  RCALL  240A
2824:  MOVFF  01,E2
2828:  CLRF   xE4
282A:  MOVLW  C1
282C:  MOVWF  xE3
282E:  RCALL  240A
2830:  MOVFF  01,E3
2834:  MOVFF  FF2,E4
2838:  BCF    FF2.7
283A:  MOVFF  E3,FA9
283E:  BCF    FA6.6
2840:  BCF    FA6.7
2842:  BSF    FA6.0
2844:  MOVF   FA8,W
2846:  BTFSC  xE4.7
2848:  BSF    FF2.7
284A:  MOVWF  xE4
284C:  CLRF   xE5
284E:  MOVF   xE5,W
2850:  CALL   06F0
2854:  INCF   xE5,F
2856:  MOVWF  00
2858:  MOVF   00,W
285A:  CLRWDT
285C:  BTFSS  F9E.4
285E:  BRA    285A
2860:  MOVWF  FAD
2862:  MOVLW  0B
2864:  SUBWF  xE5,W
2866:  BNZ   284E
2868:  CLRF   18
286A:  BTFSC  FF2.7
286C:  BSF    18.7
286E:  BCF    FF2.7
2870:  MOVFF  E2,102
2874:  MOVLW  37
2876:  MOVLB  1
2878:  MOVWF  x03
287A:  MOVLB  0
287C:  CALL   1B04
2880:  BTFSC  18.7
2882:  BSF    FF2.7
2884:  MOVLW  3D
2886:  CLRWDT
2888:  BTFSS  F9E.4
288A:  BRA    2886
288C:  MOVWF  FAD
288E:  MOVLW  30
2890:  CLRWDT
2892:  BTFSS  F9E.4
2894:  BRA    2890
2896:  MOVWF  FAD
2898:  MOVLW  78
289A:  CLRWDT
289C:  BTFSS  F9E.4
289E:  BRA    289A
28A0:  MOVWF  FAD
28A2:  CLRF   18
28A4:  BTFSC  FF2.7
28A6:  BSF    18.7
28A8:  BCF    FF2.7
28AA:  MOVFF  E4,102
28AE:  MOVLW  37
28B0:  MOVLB  1
28B2:  MOVWF  x03
28B4:  MOVLB  0
28B6:  CALL   1B04
28BA:  BTFSC  18.7
28BC:  BSF    FF2.7
28BE:  MOVLW  0A
28C0:  CLRWDT
28C2:  BTFSS  F9E.4
28C4:  BRA    28C0
28C6:  MOVWF  FAD
28C8:  MOVLW  0D
28CA:  CLRWDT
28CC:  BTFSS  F9E.4
28CE:  BRA    28CA
28D0:  MOVWF  FAD
....................    } 
....................    else if (cc=='w') 
28D2:  GOTO   30D0
28D6:  MOVF   xDF,W
28D8:  SUBLW  77
28DA:  BTFSS  FD8.2
28DC:  BRA    29BA
....................    { 
....................       printf("Endereco a escrever?:"); 
28DE:  CLRF   xE2
28E0:  MOVF   xE2,W
28E2:  CALL   0720
28E6:  INCF   xE2,F
28E8:  MOVWF  00
28EA:  CLRWDT
28EC:  BTFSS  F9E.4
28EE:  BRA    28EA
28F0:  MOVWF  FAD
28F2:  MOVLW  15
28F4:  SUBWF  xE2,W
28F6:  BNZ   28E0
....................       gets(string); 
28F8:  CLRF   FEA
28FA:  MOVLW  C1
28FC:  MOVWF  FE9
28FE:  DECF   FE9,F
2900:  INCF   FE9,F
2902:  CLRWDT
2904:  BTFSS  F9E.5
2906:  BRA    2902
2908:  MOVFF  FAE,FEF
290C:  MOVLW  0D
290E:  SUBWF  FEF,W
2910:  BNZ   2900
2912:  CLRF   FEF
....................       ci=atoi(string); 
2914:  CLRF   xE4
2916:  MOVLW  C1
2918:  MOVWF  xE3
291A:  RCALL  240A
291C:  MOVFF  01,E0
....................       printf("Endereco a escrever?:"); 
2920:  CLRF   xE2
2922:  MOVF   xE2,W
2924:  CALL   0720
2928:  INCF   xE2,F
292A:  MOVWF  00
292C:  CLRWDT
292E:  BTFSS  F9E.4
2930:  BRA    292C
2932:  MOVWF  FAD
2934:  MOVLW  15
2936:  SUBWF  xE2,W
2938:  BNZ   2922
....................       ci2=atoi(string); 
293A:  CLRF   xE4
293C:  MOVLW  C1
293E:  MOVWF  xE3
2940:  RCALL  240A
2942:  MOVFF  01,E1
....................       printf("\n\r Gravar? Y/N \n\r"); 
2946:  CLRF   xE2
2948:  MOVF   xE2,W
294A:  CALL   0698
294E:  INCF   xE2,F
2950:  MOVWF  00
2952:  CLRWDT
2954:  BTFSS  F9E.4
2956:  BRA    2952
2958:  MOVWF  FAD
295A:  MOVLW  11
295C:  SUBWF  xE2,W
295E:  BNZ   2948
....................       gets(string); 
2960:  CLRF   FEA
2962:  MOVLW  C1
2964:  MOVWF  FE9
2966:  DECF   FE9,F
2968:  INCF   FE9,F
296A:  CLRWDT
296C:  BTFSS  F9E.5
296E:  BRA    296A
2970:  MOVFF  FAE,FEF
2974:  MOVLW  0D
2976:  SUBWF  FEF,W
2978:  BNZ   2968
297A:  CLRF   FEF
....................       if (string=="y") write_eeprom(ci,ci2); 
297C:  MOVLW  0D
297E:  MOVWF  03
2980:  MOVLW  D0
2982:  SUBLW  C1
2984:  BNZ   29B6
2986:  MOVF   03,F
2988:  BNZ   29B6
298A:  MOVFF  E0,FA9
298E:  MOVFF  E1,FA8
2992:  BCF    FA6.6
2994:  BCF    FA6.7
2996:  BSF    FA6.2
2998:  MOVFF  FF2,00
299C:  BCF    FF2.7
299E:  MOVLB  F
29A0:  MOVLW  55
29A2:  MOVWF  FA7
29A4:  MOVLW  AA
29A6:  MOVWF  FA7
29A8:  BSF    FA6.1
29AA:  BTFSC  FA6.1
29AC:  BRA    29AA
29AE:  BCF    FA6.2
29B0:  MOVF   00,W
29B2:  IORWF  FF2,F
29B4:  MOVLB  0
....................    } 
....................        
....................    else if (cc=='q') reset_cpu(); 
29B6:  GOTO   30D0
29BA:  MOVF   xDF,W
29BC:  SUBLW  71
29BE:  BNZ   29C6
29C0:  RESET
....................    else if (cc=='c') 
29C2:  GOTO   30D0
29C6:  MOVF   xDF,W
29C8:  SUBLW  63
29CA:  BTFSS  FD8.2
29CC:  GOTO   30D0
....................    { 
....................    printf("************************\n\r"); 
29D0:  CLRF   xE2
29D2:  MOVF   xE2,W
29D4:  CALL   0750
29D8:  INCF   xE2,F
29DA:  MOVWF  00
29DC:  CLRWDT
29DE:  BTFSS  F9E.4
29E0:  BRA    29DC
29E2:  MOVWF  FAD
29E4:  MOVLW  1A
29E6:  SUBWF  xE2,W
29E8:  BNZ   29D2
....................    printf("* Current BRP=%u       *\n\r",read_eeprom(EADRESS)); 
29EA:  MOVFF  FF2,E2
29EE:  BCF    FF2.7
29F0:  MOVLW  04
29F2:  MOVWF  FA9
29F4:  BCF    FA6.6
29F6:  BCF    FA6.7
29F8:  BSF    FA6.0
29FA:  MOVF   FA8,W
29FC:  BTFSC  xE2.7
29FE:  BSF    FF2.7
2A00:  MOVWF  xE3
2A02:  CLRF   xE4
2A04:  MOVF   xE4,W
2A06:  CALL   0786
2A0A:  INCF   xE4,F
2A0C:  MOVWF  00
2A0E:  MOVF   00,W
2A10:  CLRWDT
2A12:  BTFSS  F9E.4
2A14:  BRA    2A10
2A16:  MOVWF  FAD
2A18:  MOVLW  0E
2A1A:  SUBWF  xE4,W
2A1C:  BNZ   2A04
2A1E:  CLRF   18
2A20:  BTFSC  FF2.7
2A22:  BSF    18.7
2A24:  BCF    FF2.7
2A26:  MOVFF  E3,102
2A2A:  MOVLW  1B
2A2C:  MOVLB  1
2A2E:  MOVWF  x03
2A30:  MOVLB  0
2A32:  CALL   0ED6
2A36:  BTFSC  18.7
2A38:  BSF    FF2.7
2A3A:  MOVLW  10
2A3C:  MOVWF  xE5
2A3E:  MOVF   xE5,W
2A40:  CALL   0786
2A44:  INCF   xE5,F
2A46:  MOVWF  00
2A48:  MOVF   00,W
2A4A:  CLRWDT
2A4C:  BTFSS  F9E.4
2A4E:  BRA    2A4A
2A50:  MOVWF  FAD
2A52:  MOVLW  1A
2A54:  SUBWF  xE5,W
2A56:  BNZ   2A3E
....................    printf("* Current SJW=%u       *\n\r",read_eeprom(ESJW)); 
2A58:  MOVFF  FF2,E2
2A5C:  BCF    FF2.7
2A5E:  MOVLW  06
2A60:  MOVWF  FA9
2A62:  BCF    FA6.6
2A64:  BCF    FA6.7
2A66:  BSF    FA6.0
2A68:  MOVF   FA8,W
2A6A:  BTFSC  xE2.7
2A6C:  BSF    FF2.7
2A6E:  MOVWF  xE3
2A70:  CLRF   xE4
2A72:  MOVF   xE4,W
2A74:  CALL   07BC
2A78:  INCF   xE4,F
2A7A:  MOVWF  00
2A7C:  MOVF   00,W
2A7E:  CLRWDT
2A80:  BTFSS  F9E.4
2A82:  BRA    2A7E
2A84:  MOVWF  FAD
2A86:  MOVLW  0E
2A88:  SUBWF  xE4,W
2A8A:  BNZ   2A72
2A8C:  CLRF   18
2A8E:  BTFSC  FF2.7
2A90:  BSF    18.7
2A92:  BCF    FF2.7
2A94:  MOVFF  E3,102
2A98:  MOVLW  1B
2A9A:  MOVLB  1
2A9C:  MOVWF  x03
2A9E:  MOVLB  0
2AA0:  CALL   0ED6
2AA4:  BTFSC  18.7
2AA6:  BSF    FF2.7
2AA8:  MOVLW  10
2AAA:  MOVWF  xE5
2AAC:  MOVF   xE5,W
2AAE:  CALL   07BC
2AB2:  INCF   xE5,F
2AB4:  MOVWF  00
2AB6:  MOVF   00,W
2AB8:  CLRWDT
2ABA:  BTFSS  F9E.4
2ABC:  BRA    2AB8
2ABE:  MOVWF  FAD
2AC0:  MOVLW  1A
2AC2:  SUBWF  xE5,W
2AC4:  BNZ   2AAC
....................    printf("* Current PHSEG1=%u    *\n\r",read_eeprom(EPHSEG1)); 
2AC6:  MOVFF  FF2,E2
2ACA:  BCF    FF2.7
2ACC:  MOVLW  01
2ACE:  MOVWF  FA9
2AD0:  BCF    FA6.6
2AD2:  BCF    FA6.7
2AD4:  BSF    FA6.0
2AD6:  MOVF   FA8,W
2AD8:  BTFSC  xE2.7
2ADA:  BSF    FF2.7
2ADC:  MOVWF  xE3
2ADE:  CLRF   xE4
2AE0:  MOVF   xE4,W
2AE2:  CALL   07F2
2AE6:  INCF   xE4,F
2AE8:  MOVWF  00
2AEA:  MOVF   00,W
2AEC:  CLRWDT
2AEE:  BTFSS  F9E.4
2AF0:  BRA    2AEC
2AF2:  MOVWF  FAD
2AF4:  MOVLW  11
2AF6:  SUBWF  xE4,W
2AF8:  BNZ   2AE0
2AFA:  CLRF   18
2AFC:  BTFSC  FF2.7
2AFE:  BSF    18.7
2B00:  BCF    FF2.7
2B02:  MOVFF  E3,102
2B06:  MOVLW  1B
2B08:  MOVLB  1
2B0A:  MOVWF  x03
2B0C:  MOVLB  0
2B0E:  CALL   0ED6
2B12:  BTFSC  18.7
2B14:  BSF    FF2.7
2B16:  MOVLW  13
2B18:  MOVWF  xE5
2B1A:  MOVF   xE5,W
2B1C:  CALL   07F2
2B20:  INCF   xE5,F
2B22:  MOVWF  00
2B24:  MOVF   00,W
2B26:  CLRWDT
2B28:  BTFSS  F9E.4
2B2A:  BRA    2B26
2B2C:  MOVWF  FAD
2B2E:  MOVLW  1A
2B30:  SUBWF  xE5,W
2B32:  BNZ   2B1A
....................    printf("* Current SEG2PHTS=%u  *\n\r",read_eeprom(ESEG2PHTS)); 
2B34:  MOVFF  FF2,E2
2B38:  BCF    FF2.7
2B3A:  MOVLW  05
2B3C:  MOVWF  FA9
2B3E:  BCF    FA6.6
2B40:  BCF    FA6.7
2B42:  BSF    FA6.0
2B44:  MOVF   FA8,W
2B46:  BTFSC  xE2.7
2B48:  BSF    FF2.7
2B4A:  MOVWF  xE3
2B4C:  CLRF   xE4
2B4E:  MOVF   xE4,W
2B50:  CALL   0828
2B54:  INCF   xE4,F
2B56:  MOVWF  00
2B58:  MOVF   00,W
2B5A:  CLRWDT
2B5C:  BTFSS  F9E.4
2B5E:  BRA    2B5A
2B60:  MOVWF  FAD
2B62:  MOVLW  13
2B64:  SUBWF  xE4,W
2B66:  BNZ   2B4E
2B68:  CLRF   18
2B6A:  BTFSC  FF2.7
2B6C:  BSF    18.7
2B6E:  BCF    FF2.7
2B70:  MOVFF  E3,102
2B74:  MOVLW  1B
2B76:  MOVLB  1
2B78:  MOVWF  x03
2B7A:  MOVLB  0
2B7C:  CALL   0ED6
2B80:  BTFSC  18.7
2B82:  BSF    FF2.7
2B84:  MOVLW  15
2B86:  MOVWF  xE5
2B88:  MOVF   xE5,W
2B8A:  CALL   0828
2B8E:  INCF   xE5,F
2B90:  MOVWF  00
2B92:  MOVF   00,W
2B94:  CLRWDT
2B96:  BTFSS  F9E.4
2B98:  BRA    2B94
2B9A:  MOVWF  FAD
2B9C:  MOVLW  1A
2B9E:  SUBWF  xE5,W
2BA0:  BNZ   2B88
....................    printf("* Current PHSEG2=%u    *\n\r",read_eeprom(EPHSEG2)); 
2BA2:  MOVFF  FF2,E2
2BA6:  BCF    FF2.7
2BA8:  MOVLW  02
2BAA:  MOVWF  FA9
2BAC:  BCF    FA6.6
2BAE:  BCF    FA6.7
2BB0:  BSF    FA6.0
2BB2:  MOVF   FA8,W
2BB4:  BTFSC  xE2.7
2BB6:  BSF    FF2.7
2BB8:  MOVWF  xE3
2BBA:  CLRF   xE4
2BBC:  MOVF   xE4,W
2BBE:  CALL   085E
2BC2:  INCF   xE4,F
2BC4:  MOVWF  00
2BC6:  MOVF   00,W
2BC8:  CLRWDT
2BCA:  BTFSS  F9E.4
2BCC:  BRA    2BC8
2BCE:  MOVWF  FAD
2BD0:  MOVLW  11
2BD2:  SUBWF  xE4,W
2BD4:  BNZ   2BBC
2BD6:  CLRF   18
2BD8:  BTFSC  FF2.7
2BDA:  BSF    18.7
2BDC:  BCF    FF2.7
2BDE:  MOVFF  E3,102
2BE2:  MOVLW  1B
2BE4:  MOVLB  1
2BE6:  MOVWF  x03
2BE8:  MOVLB  0
2BEA:  CALL   0ED6
2BEE:  BTFSC  18.7
2BF0:  BSF    FF2.7
2BF2:  MOVLW  13
2BF4:  MOVWF  xE5
2BF6:  MOVF   xE5,W
2BF8:  CALL   085E
2BFC:  INCF   xE5,F
2BFE:  MOVWF  00
2C00:  MOVF   00,W
2C02:  CLRWDT
2C04:  BTFSS  F9E.4
2C06:  BRA    2C02
2C08:  MOVWF  FAD
2C0A:  MOVLW  1A
2C0C:  SUBWF  xE5,W
2C0E:  BNZ   2BF6
....................    printf("* Current PRSEG=%u     *\n\r",read_eeprom(EPRSEG));  
2C10:  MOVFF  FF2,E2
2C14:  BCF    FF2.7
2C16:  MOVLW  03
2C18:  MOVWF  FA9
2C1A:  BCF    FA6.6
2C1C:  BCF    FA6.7
2C1E:  BSF    FA6.0
2C20:  MOVF   FA8,W
2C22:  BTFSC  xE2.7
2C24:  BSF    FF2.7
2C26:  MOVWF  xE3
2C28:  CLRF   xE4
2C2A:  MOVF   xE4,W
2C2C:  CALL   0894
2C30:  INCF   xE4,F
2C32:  MOVWF  00
2C34:  MOVF   00,W
2C36:  CLRWDT
2C38:  BTFSS  F9E.4
2C3A:  BRA    2C36
2C3C:  MOVWF  FAD
2C3E:  MOVLW  10
2C40:  SUBWF  xE4,W
2C42:  BNZ   2C2A
2C44:  CLRF   18
2C46:  BTFSC  FF2.7
2C48:  BSF    18.7
2C4A:  BCF    FF2.7
2C4C:  MOVFF  E3,102
2C50:  MOVLW  1B
2C52:  MOVLB  1
2C54:  MOVWF  x03
2C56:  MOVLB  0
2C58:  CALL   0ED6
2C5C:  BTFSC  18.7
2C5E:  BSF    FF2.7
2C60:  MOVLW  12
2C62:  MOVWF  xE5
2C64:  MOVF   xE5,W
2C66:  CALL   0894
2C6A:  INCF   xE5,F
2C6C:  MOVWF  00
2C6E:  MOVF   00,W
2C70:  CLRWDT
2C72:  BTFSS  F9E.4
2C74:  BRA    2C70
2C76:  MOVWF  FAD
2C78:  MOVLW  1A
2C7A:  SUBWF  xE5,W
2C7C:  BNZ   2C64
....................    printf("************************\n\r\n\r"); 
2C7E:  CLRF   xE2
2C80:  MOVF   xE2,W
2C82:  CALL   08CA
2C86:  INCF   xE2,F
2C88:  MOVWF  00
2C8A:  CLRWDT
2C8C:  BTFSS  F9E.4
2C8E:  BRA    2C8A
2C90:  MOVWF  FAD
2C92:  MOVLW  1C
2C94:  SUBWF  xE2,W
2C96:  BNZ   2C80
....................    printf("New BRP:"); 
2C98:  CLRF   xE2
2C9A:  MOVF   xE2,W
2C9C:  CALL   0902
2CA0:  INCF   xE2,F
2CA2:  MOVWF  00
2CA4:  CLRWDT
2CA6:  BTFSS  F9E.4
2CA8:  BRA    2CA4
2CAA:  MOVWF  FAD
2CAC:  MOVLW  08
2CAE:  SUBWF  xE2,W
2CB0:  BNZ   2C9A
....................    gets(string); 
2CB2:  CLRF   FEA
2CB4:  MOVLW  C1
2CB6:  MOVWF  FE9
2CB8:  DECF   FE9,F
2CBA:  INCF   FE9,F
2CBC:  CLRWDT
2CBE:  BTFSS  F9E.5
2CC0:  BRA    2CBC
2CC2:  MOVFF  FAE,FEF
2CC6:  MOVLW  0D
2CC8:  SUBWF  FEF,W
2CCA:  BNZ   2CBA
2CCC:  CLRF   FEF
....................    ci=atoi(string); 
2CCE:  CLRF   xE4
2CD0:  MOVLW  C1
2CD2:  MOVWF  xE3
2CD4:  CALL   240A
2CD8:  MOVFF  01,E0
....................    printf("\n\r Gravar novo BRP Y/N \n\r"); 
2CDC:  CLRF   xE2
2CDE:  MOVF   xE2,W
2CE0:  CALL   0926
2CE4:  INCF   xE2,F
2CE6:  MOVWF  00
2CE8:  CLRWDT
2CEA:  BTFSS  F9E.4
2CEC:  BRA    2CE8
2CEE:  MOVWF  FAD
2CF0:  MOVLW  19
2CF2:  SUBWF  xE2,W
2CF4:  BNZ   2CDE
....................    gets(string); 
2CF6:  CLRF   FEA
2CF8:  MOVLW  C1
2CFA:  MOVWF  FE9
2CFC:  DECF   FE9,F
2CFE:  INCF   FE9,F
2D00:  CLRWDT
2D02:  BTFSS  F9E.5
2D04:  BRA    2D00
2D06:  MOVFF  FAE,FEF
2D0A:  MOVLW  0D
2D0C:  SUBWF  FEF,W
2D0E:  BNZ   2CFE
2D10:  CLRF   FEF
....................    if (string=="y") write_eeprom(EBRP,ci); 
2D12:  MOVLW  0D
2D14:  MOVWF  03
2D16:  MOVLW  D2
2D18:  SUBLW  C1
2D1A:  BNZ   2D4C
2D1C:  MOVF   03,F
2D1E:  BNZ   2D4C
2D20:  MOVLW  07
2D22:  MOVWF  FA9
2D24:  MOVFF  E0,FA8
2D28:  BCF    FA6.6
2D2A:  BCF    FA6.7
2D2C:  BSF    FA6.2
2D2E:  MOVFF  FF2,00
2D32:  BCF    FF2.7
2D34:  MOVLB  F
2D36:  MOVLW  55
2D38:  MOVWF  FA7
2D3A:  MOVLW  AA
2D3C:  MOVWF  FA7
2D3E:  BSF    FA6.1
2D40:  BTFSC  FA6.1
2D42:  BRA    2D40
2D44:  BCF    FA6.2
2D46:  MOVF   00,W
2D48:  IORWF  FF2,F
2D4A:  MOVLB  0
....................    printf("New PHSEG1:"); 
2D4C:  CLRF   xE2
2D4E:  MOVF   xE2,W
2D50:  CALL   095A
2D54:  INCF   xE2,F
2D56:  MOVWF  00
2D58:  CLRWDT
2D5A:  BTFSS  F9E.4
2D5C:  BRA    2D58
2D5E:  MOVWF  FAD
2D60:  MOVLW  0B
2D62:  SUBWF  xE2,W
2D64:  BNZ   2D4E
....................    gets(string); 
2D66:  CLRF   FEA
2D68:  MOVLW  C1
2D6A:  MOVWF  FE9
2D6C:  DECF   FE9,F
2D6E:  INCF   FE9,F
2D70:  CLRWDT
2D72:  BTFSS  F9E.5
2D74:  BRA    2D70
2D76:  MOVFF  FAE,FEF
2D7A:  MOVLW  0D
2D7C:  SUBWF  FEF,W
2D7E:  BNZ   2D6E
2D80:  CLRF   FEF
....................    ci=atoi(string); 
2D82:  CLRF   xE4
2D84:  MOVLW  C1
2D86:  MOVWF  xE3
2D88:  CALL   240A
2D8C:  MOVFF  01,E0
....................    printf("\n\r Gravar novo PHSEG1 Y/N \n\r"); 
2D90:  CLRF   xE2
2D92:  MOVF   xE2,W
2D94:  CALL   0980
2D98:  INCF   xE2,F
2D9A:  MOVWF  00
2D9C:  CLRWDT
2D9E:  BTFSS  F9E.4
2DA0:  BRA    2D9C
2DA2:  MOVWF  FAD
2DA4:  MOVLW  1C
2DA6:  SUBWF  xE2,W
2DA8:  BNZ   2D92
....................    gets(string); 
2DAA:  CLRF   FEA
2DAC:  MOVLW  C1
2DAE:  MOVWF  FE9
2DB0:  DECF   FE9,F
2DB2:  INCF   FE9,F
2DB4:  CLRWDT
2DB6:  BTFSS  F9E.5
2DB8:  BRA    2DB4
2DBA:  MOVFF  FAE,FEF
2DBE:  MOVLW  0D
2DC0:  SUBWF  FEF,W
2DC2:  BNZ   2DB2
2DC4:  CLRF   FEF
....................    if (string=="y") write_eeprom(EPHSEG1,ci); 
2DC6:  MOVLW  0D
2DC8:  MOVWF  03
2DCA:  MOVLW  D4
2DCC:  SUBLW  C1
2DCE:  BNZ   2E00
2DD0:  MOVF   03,F
2DD2:  BNZ   2E00
2DD4:  MOVLW  01
2DD6:  MOVWF  FA9
2DD8:  MOVFF  E0,FA8
2DDC:  BCF    FA6.6
2DDE:  BCF    FA6.7
2DE0:  BSF    FA6.2
2DE2:  MOVFF  FF2,00
2DE6:  BCF    FF2.7
2DE8:  MOVLB  F
2DEA:  MOVLW  55
2DEC:  MOVWF  FA7
2DEE:  MOVLW  AA
2DF0:  MOVWF  FA7
2DF2:  BSF    FA6.1
2DF4:  BTFSC  FA6.1
2DF6:  BRA    2DF4
2DF8:  BCF    FA6.2
2DFA:  MOVF   00,W
2DFC:  IORWF  FF2,F
2DFE:  MOVLB  0
....................    printf("New PHSEG2:"); 
2E00:  CLRF   xE2
2E02:  MOVF   xE2,W
2E04:  CALL   09B8
2E08:  INCF   xE2,F
2E0A:  MOVWF  00
2E0C:  CLRWDT
2E0E:  BTFSS  F9E.4
2E10:  BRA    2E0C
2E12:  MOVWF  FAD
2E14:  MOVLW  0B
2E16:  SUBWF  xE2,W
2E18:  BNZ   2E02
....................    gets(string); 
2E1A:  CLRF   FEA
2E1C:  MOVLW  C1
2E1E:  MOVWF  FE9
2E20:  DECF   FE9,F
2E22:  INCF   FE9,F
2E24:  CLRWDT
2E26:  BTFSS  F9E.5
2E28:  BRA    2E24
2E2A:  MOVFF  FAE,FEF
2E2E:  MOVLW  0D
2E30:  SUBWF  FEF,W
2E32:  BNZ   2E22
2E34:  CLRF   FEF
....................    ci=atoi(string); 
2E36:  CLRF   xE4
2E38:  MOVLW  C1
2E3A:  MOVWF  xE3
2E3C:  CALL   240A
2E40:  MOVFF  01,E0
....................    printf("\n\r Gravar novo PHSEG2 Y/N \n\r"); 
2E44:  CLRF   xE2
2E46:  MOVF   xE2,W
2E48:  CALL   09DE
2E4C:  INCF   xE2,F
2E4E:  MOVWF  00
2E50:  CLRWDT
2E52:  BTFSS  F9E.4
2E54:  BRA    2E50
2E56:  MOVWF  FAD
2E58:  MOVLW  1C
2E5A:  SUBWF  xE2,W
2E5C:  BNZ   2E46
....................    gets(string); 
2E5E:  CLRF   FEA
2E60:  MOVLW  C1
2E62:  MOVWF  FE9
2E64:  DECF   FE9,F
2E66:  INCF   FE9,F
2E68:  CLRWDT
2E6A:  BTFSS  F9E.5
2E6C:  BRA    2E68
2E6E:  MOVFF  FAE,FEF
2E72:  MOVLW  0D
2E74:  SUBWF  FEF,W
2E76:  BNZ   2E66
2E78:  CLRF   FEF
....................    if (string=="y") write_eeprom(EPHSEG2,ci); 
2E7A:  MOVLW  0D
2E7C:  MOVWF  03
2E7E:  MOVLW  D6
2E80:  SUBLW  C1
2E82:  BNZ   2EB4
2E84:  MOVF   03,F
2E86:  BNZ   2EB4
2E88:  MOVLW  02
2E8A:  MOVWF  FA9
2E8C:  MOVFF  E0,FA8
2E90:  BCF    FA6.6
2E92:  BCF    FA6.7
2E94:  BSF    FA6.2
2E96:  MOVFF  FF2,00
2E9A:  BCF    FF2.7
2E9C:  MOVLB  F
2E9E:  MOVLW  55
2EA0:  MOVWF  FA7
2EA2:  MOVLW  AA
2EA4:  MOVWF  FA7
2EA6:  BSF    FA6.1
2EA8:  BTFSC  FA6.1
2EAA:  BRA    2EA8
2EAC:  BCF    FA6.2
2EAE:  MOVF   00,W
2EB0:  IORWF  FF2,F
2EB2:  MOVLB  0
....................    printf("New PRSEG:"); 
2EB4:  CLRF   xE2
2EB6:  MOVF   xE2,W
2EB8:  CALL   0A16
2EBC:  INCF   xE2,F
2EBE:  MOVWF  00
2EC0:  CLRWDT
2EC2:  BTFSS  F9E.4
2EC4:  BRA    2EC0
2EC6:  MOVWF  FAD
2EC8:  MOVLW  0A
2ECA:  SUBWF  xE2,W
2ECC:  BNZ   2EB6
....................    gets(string); 
2ECE:  CLRF   FEA
2ED0:  MOVLW  C1
2ED2:  MOVWF  FE9
2ED4:  DECF   FE9,F
2ED6:  INCF   FE9,F
2ED8:  CLRWDT
2EDA:  BTFSS  F9E.5
2EDC:  BRA    2ED8
2EDE:  MOVFF  FAE,FEF
2EE2:  MOVLW  0D
2EE4:  SUBWF  FEF,W
2EE6:  BNZ   2ED6
2EE8:  CLRF   FEF
....................    ci=atoi(string); 
2EEA:  CLRF   xE4
2EEC:  MOVLW  C1
2EEE:  MOVWF  xE3
2EF0:  CALL   240A
2EF4:  MOVFF  01,E0
....................    printf("\n\r Gravar novo PRSEG Y/N \n\r"); 
2EF8:  CLRF   xE2
2EFA:  MOVF   xE2,W
2EFC:  CALL   0A3C
2F00:  INCF   xE2,F
2F02:  MOVWF  00
2F04:  CLRWDT
2F06:  BTFSS  F9E.4
2F08:  BRA    2F04
2F0A:  MOVWF  FAD
2F0C:  MOVLW  1B
2F0E:  SUBWF  xE2,W
2F10:  BNZ   2EFA
....................    gets(string); 
2F12:  CLRF   FEA
2F14:  MOVLW  C1
2F16:  MOVWF  FE9
2F18:  DECF   FE9,F
2F1A:  INCF   FE9,F
2F1C:  CLRWDT
2F1E:  BTFSS  F9E.5
2F20:  BRA    2F1C
2F22:  MOVFF  FAE,FEF
2F26:  MOVLW  0D
2F28:  SUBWF  FEF,W
2F2A:  BNZ   2F1A
2F2C:  CLRF   FEF
....................    if (string=="y") write_eeprom(EPRSEG,ci); 
2F2E:  MOVLW  0D
2F30:  MOVWF  03
2F32:  MOVLW  D8
2F34:  SUBLW  C1
2F36:  BNZ   2F68
2F38:  MOVF   03,F
2F3A:  BNZ   2F68
2F3C:  MOVLW  03
2F3E:  MOVWF  FA9
2F40:  MOVFF  E0,FA8
2F44:  BCF    FA6.6
2F46:  BCF    FA6.7
2F48:  BSF    FA6.2
2F4A:  MOVFF  FF2,00
2F4E:  BCF    FF2.7
2F50:  MOVLB  F
2F52:  MOVLW  55
2F54:  MOVWF  FA7
2F56:  MOVLW  AA
2F58:  MOVWF  FA7
2F5A:  BSF    FA6.1
2F5C:  BTFSC  FA6.1
2F5E:  BRA    2F5C
2F60:  BCF    FA6.2
2F62:  MOVF   00,W
2F64:  IORWF  FF2,F
2F66:  MOVLB  0
....................    printf("New SJW:"); 
2F68:  CLRF   xE2
2F6A:  MOVF   xE2,W
2F6C:  CALL   0A72
2F70:  INCF   xE2,F
2F72:  MOVWF  00
2F74:  CLRWDT
2F76:  BTFSS  F9E.4
2F78:  BRA    2F74
2F7A:  MOVWF  FAD
2F7C:  MOVLW  08
2F7E:  SUBWF  xE2,W
2F80:  BNZ   2F6A
....................    gets(string); 
2F82:  CLRF   FEA
2F84:  MOVLW  C1
2F86:  MOVWF  FE9
2F88:  DECF   FE9,F
2F8A:  INCF   FE9,F
2F8C:  CLRWDT
2F8E:  BTFSS  F9E.5
2F90:  BRA    2F8C
2F92:  MOVFF  FAE,FEF
2F96:  MOVLW  0D
2F98:  SUBWF  FEF,W
2F9A:  BNZ   2F8A
2F9C:  CLRF   FEF
....................    ci=atoi(string); 
2F9E:  CLRF   xE4
2FA0:  MOVLW  C1
2FA2:  MOVWF  xE3
2FA4:  CALL   240A
2FA8:  MOVFF  01,E0
....................    printf("\n\r Gravar novo SJW Y/N \n\r"); 
2FAC:  CLRF   xE2
2FAE:  MOVF   xE2,W
2FB0:  CALL   0A96
2FB4:  INCF   xE2,F
2FB6:  MOVWF  00
2FB8:  CLRWDT
2FBA:  BTFSS  F9E.4
2FBC:  BRA    2FB8
2FBE:  MOVWF  FAD
2FC0:  MOVLW  19
2FC2:  SUBWF  xE2,W
2FC4:  BNZ   2FAE
....................    gets(string); 
2FC6:  CLRF   FEA
2FC8:  MOVLW  C1
2FCA:  MOVWF  FE9
2FCC:  DECF   FE9,F
2FCE:  INCF   FE9,F
2FD0:  CLRWDT
2FD2:  BTFSS  F9E.5
2FD4:  BRA    2FD0
2FD6:  MOVFF  FAE,FEF
2FDA:  MOVLW  0D
2FDC:  SUBWF  FEF,W
2FDE:  BNZ   2FCE
2FE0:  CLRF   FEF
....................    if (string=="y") write_eeprom(ESJW,ci); 
2FE2:  MOVLW  0D
2FE4:  MOVWF  03
2FE6:  MOVLW  DA
2FE8:  SUBLW  C1
2FEA:  BNZ   301C
2FEC:  MOVF   03,F
2FEE:  BNZ   301C
2FF0:  MOVLW  06
2FF2:  MOVWF  FA9
2FF4:  MOVFF  E0,FA8
2FF8:  BCF    FA6.6
2FFA:  BCF    FA6.7
2FFC:  BSF    FA6.2
2FFE:  MOVFF  FF2,00
3002:  BCF    FF2.7
3004:  MOVLB  F
3006:  MOVLW  55
3008:  MOVWF  FA7
300A:  MOVLW  AA
300C:  MOVWF  FA7
300E:  BSF    FA6.1
3010:  BTFSC  FA6.1
3012:  BRA    3010
3014:  BCF    FA6.2
3016:  MOVF   00,W
3018:  IORWF  FF2,F
301A:  MOVLB  0
....................    printf("New SEG2PHTS:"); 
301C:  CLRF   xE2
301E:  MOVF   xE2,W
3020:  CALL   0ACA
3024:  INCF   xE2,F
3026:  MOVWF  00
3028:  CLRWDT
302A:  BTFSS  F9E.4
302C:  BRA    3028
302E:  MOVWF  FAD
3030:  MOVLW  0D
3032:  SUBWF  xE2,W
3034:  BNZ   301E
....................    gets(string); 
3036:  CLRF   FEA
3038:  MOVLW  C1
303A:  MOVWF  FE9
303C:  DECF   FE9,F
303E:  INCF   FE9,F
3040:  CLRWDT
3042:  BTFSS  F9E.5
3044:  BRA    3040
3046:  MOVFF  FAE,FEF
304A:  MOVLW  0D
304C:  SUBWF  FEF,W
304E:  BNZ   303E
3050:  CLRF   FEF
....................    ci=atoi(string); 
3052:  CLRF   xE4
3054:  MOVLW  C1
3056:  MOVWF  xE3
3058:  CALL   240A
305C:  MOVFF  01,E0
....................    printf("\n\r Gravar novo SEG2PHTS Y/N \n\r"); 
3060:  CLRF   xE2
3062:  MOVF   xE2,W
3064:  CALL   0AF2
3068:  INCF   xE2,F
306A:  MOVWF  00
306C:  CLRWDT
306E:  BTFSS  F9E.4
3070:  BRA    306C
3072:  MOVWF  FAD
3074:  MOVLW  1E
3076:  SUBWF  xE2,W
3078:  BNZ   3062
....................    gets(string); 
307A:  CLRF   FEA
307C:  MOVLW  C1
307E:  MOVWF  FE9
3080:  DECF   FE9,F
3082:  INCF   FE9,F
3084:  CLRWDT
3086:  BTFSS  F9E.5
3088:  BRA    3084
308A:  MOVFF  FAE,FEF
308E:  MOVLW  0D
3090:  SUBWF  FEF,W
3092:  BNZ   3082
3094:  CLRF   FEF
....................    if (string=="y") write_eeprom(ESEG2PHTS,ci); 
3096:  MOVLW  0D
3098:  MOVWF  03
309A:  MOVLW  DC
309C:  SUBLW  C1
309E:  BNZ   30D0
30A0:  MOVF   03,F
30A2:  BNZ   30D0
30A4:  MOVLW  05
30A6:  MOVWF  FA9
30A8:  MOVFF  E0,FA8
30AC:  BCF    FA6.6
30AE:  BCF    FA6.7
30B0:  BSF    FA6.2
30B2:  MOVFF  FF2,00
30B6:  BCF    FF2.7
30B8:  MOVLB  F
30BA:  MOVLW  55
30BC:  MOVWF  FA7
30BE:  MOVLW  AA
30C0:  MOVWF  FA7
30C2:  BSF    FA6.1
30C4:  BTFSC  FA6.1
30C6:  BRA    30C4
30C8:  BCF    FA6.2
30CA:  MOVF   00,W
30CC:  IORWF  FF2,F
30CE:  MOVLB  0
....................    } 
.................... } 
30D0:  GOTO   25A4
.................... } 
30D4:  GOTO   39DC (RETURN)
....................  
....................  
.................... int DEBUG_MODE; 
.................... char ch; 
....................  
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................   ch=getc(); 
*
1556:  CLRWDT
1558:  BTFSS  F9E.5
155A:  BRA    1556
155C:  MOVFF  FAE,30
....................   console(ch); 
1560:  MOVFF  30,F1
1564:  BRA    1352
....................     
.................... } 
....................  
1566:  BCF    F9E.5
1568:  GOTO   00C4
.................... #int_LOWVOLT 
.................... void  LOWVOLT_isr(void)  
.................... { 
....................    printf("ERROR LOW VOLTAGE DETECTED\n\r"); 
156C:  CLRF   xF1
156E:  MOVF   xF1,W
1570:  CALL   0B2C
1574:  INCF   xF1,F
1576:  MOVWF  00
1578:  CLRWDT
157A:  BTFSS  F9E.4
157C:  BRA    1578
157E:  MOVWF  FAD
1580:  MOVLW  1C
1582:  SUBWF  xF1,W
1584:  BNZ   156E
.................... } 
....................  
....................  
....................  
1586:  BCF    FA1.2
1588:  GOTO   00C4
.................... #int_OSCF 
.................... void  OSCF_isr(void)  
.................... { 
....................  
.................... } 
....................  
....................   
....................  
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
158C:  BCF    FA1.7
158E:  GOTO   00C4
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int void76:2;   //6:7 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON=0xF40 
.................... #byte   TXB1CON=0xF30 
.................... #byte   TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH=0xF61 
.................... #byte   RXB0SIDL=0xF62 
.................... #byte   RXB1SIDH=0xF51 
.................... #byte   RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH=0xF63 
.................... #byte   RXB0EIDL=0xF64 
.................... #byte   RXB1EIDH=0xF53 
.................... #byte   RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC=0xF65 
.................... #byte   RXB1DLC=0xF55 
.................... #byte   RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
312A:  MOVLW  04
312C:  MOVWF  xC1
312E:  RCALL  30D8
....................    can_set_baud(); 
3130:  BRA    30FA
....................  
....................    RXB0CON=0; 
3132:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
3134:  MOVLW  9F
3136:  ANDWF  F60,W
3138:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
313A:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
313C:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
3140:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
3142:  BCF    F73.4
3144:  CLRF   18
3146:  BTFSC  FF2.7
3148:  BSF    18.7
314A:  BCF    FF2.7
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
314C:  MOVLW  0F
314E:  MOVLB  1
3150:  MOVWF  x12
3152:  MOVLW  1B
3154:  MOVWF  x11
3156:  CLRF   x16
3158:  CLRF   x15
315A:  CLRF   x14
315C:  CLRF   x13
315E:  CLRF   x17
3160:  MOVLB  0
3162:  CALL   1F30
3166:  BTFSC  18.7
3168:  BSF    FF2.7
316A:  CLRF   18
316C:  BTFSC  FF2.7
316E:  BSF    18.7
3170:  BCF    FF2.7
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
3172:  MOVLW  0F
3174:  MOVLB  1
3176:  MOVWF  x12
3178:  MOVLW  03
317A:  MOVWF  x11
317C:  CLRF   x16
317E:  CLRF   x15
3180:  CLRF   x14
3182:  CLRF   x13
3184:  CLRF   x17
3186:  MOVLB  0
3188:  CALL   1F30
318C:  BTFSC  18.7
318E:  BSF    FF2.7
3190:  CLRF   18
3192:  BTFSC  FF2.7
3194:  BSF    18.7
3196:  BCF    FF2.7
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
3198:  MOVLW  0F
319A:  MOVLB  1
319C:  MOVWF  x12
319E:  MOVLW  07
31A0:  MOVWF  x11
31A2:  CLRF   x16
31A4:  CLRF   x15
31A6:  CLRF   x14
31A8:  CLRF   x13
31AA:  CLRF   x17
31AC:  MOVLB  0
31AE:  CALL   1F30
31B2:  BTFSC  18.7
31B4:  BSF    FF2.7
31B6:  CLRF   18
31B8:  BTFSC  FF2.7
31BA:  BSF    18.7
31BC:  BCF    FF2.7
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
31BE:  MOVLW  0F
31C0:  MOVLB  1
31C2:  MOVWF  x12
31C4:  MOVLW  1F
31C6:  MOVWF  x11
31C8:  CLRF   x16
31CA:  CLRF   x15
31CC:  CLRF   x14
31CE:  CLRF   x13
31D0:  CLRF   x17
31D2:  MOVLB  0
31D4:  CALL   1F30
31D8:  BTFSC  18.7
31DA:  BSF    FF2.7
31DC:  CLRF   18
31DE:  BTFSC  FF2.7
31E0:  BSF    18.7
31E2:  BCF    FF2.7
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
31E4:  MOVLW  0F
31E6:  MOVLB  1
31E8:  MOVWF  x12
31EA:  MOVLW  0B
31EC:  MOVWF  x11
31EE:  CLRF   x16
31F0:  CLRF   x15
31F2:  CLRF   x14
31F4:  CLRF   x13
31F6:  CLRF   x17
31F8:  MOVLB  0
31FA:  CALL   1F30
31FE:  BTFSC  18.7
3200:  BSF    FF2.7
3202:  CLRF   18
3204:  BTFSC  FF2.7
3206:  BSF    18.7
3208:  BCF    FF2.7
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
320A:  MOVLW  0F
320C:  MOVLB  1
320E:  MOVWF  x12
3210:  MOVWF  x11
3212:  CLRF   x16
3214:  CLRF   x15
3216:  CLRF   x14
3218:  CLRF   x13
321A:  CLRF   x17
321C:  MOVLB  0
321E:  CALL   1F30
3222:  BTFSC  18.7
3224:  BSF    FF2.7
3226:  CLRF   18
3228:  BTFSC  FF2.7
322A:  BSF    18.7
322C:  BCF    FF2.7
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
322E:  MOVLW  0F
3230:  MOVLB  1
3232:  MOVWF  x12
3234:  MOVLW  13
3236:  MOVWF  x11
3238:  CLRF   x16
323A:  CLRF   x15
323C:  CLRF   x14
323E:  CLRF   x13
3240:  CLRF   x17
3242:  MOVLB  0
3244:  CALL   1F30
3248:  BTFSC  18.7
324A:  BSF    FF2.7
324C:  CLRF   18
324E:  BTFSC  FF2.7
3250:  BSF    18.7
3252:  BCF    FF2.7
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
3254:  MOVLW  0F
3256:  MOVLB  1
3258:  MOVWF  x12
325A:  MOVLW  17
325C:  MOVWF  x11
325E:  CLRF   x16
3260:  CLRF   x15
3262:  CLRF   x14
3264:  CLRF   x13
3266:  CLRF   x17
3268:  MOVLB  0
326A:  CALL   1F30
326E:  BTFSC  18.7
3270:  BSF    FF2.7
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
3272:  MOVF   F93,W
3274:  ANDLW  FB
3276:  IORLW  08
3278:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
327A:  CLRF   xC1
327C:  RCALL  30D8
.................... } 
327E:  GOTO   3A18 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
30FA:  MOVLW  C0
30FC:  ANDWF  F70,W
30FE:  IORLW  04
3100:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
3102:  MOVLW  3F
3104:  ANDWF  F70,W
3106:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
3108:  MOVLW  F8
310A:  ANDWF  F71,W
310C:  IORLW  02
310E:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
3110:  MOVLW  C7
3112:  ANDWF  F71,W
3114:  IORLW  28
3116:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
3118:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
311A:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
311C:  MOVLW  F8
311E:  ANDWF  F72,W
3120:  IORLW  05
3122:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
3124:  BCF    F72.6
.................... } 
3126:  GOTO   3132 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
30D8:  SWAPF  xC1,W
30DA:  ANDLW  70
30DC:  MOVWF  00
30DE:  BCF    FD8.0
30E0:  RLCF   00,F
30E2:  MOVLW  1F
30E4:  ANDWF  F6F,W
30E6:  IORWF  00,W
30E8:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
30EA:  MOVFF  F6E,00
30EE:  SWAPF  00,F
30F0:  RRCF   00,W
30F2:  ANDLW  07
30F4:  SUBWF  xC1,W
30F6:  BNZ   30EA
.................... } 
30F8:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
1F30:  MOVFF  112,119
1F34:  MOVFF  111,118
....................  
....................    if (ext) {  //extended 
1F38:  MOVLB  1
1F3A:  MOVF   x17,F
1F3C:  BZ    1FE2
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
1F3E:  MOVFF  118,FE9
1F42:  MOVFF  119,FEA
1F46:  MOVFF  113,FEF
....................  
....................       //eidh 
....................       ptr--; 
1F4A:  MOVF   x18,W
1F4C:  BTFSC  FD8.2
1F4E:  DECF   x19,F
1F50:  DECF   x18,F
....................       *ptr=make8(id,1); //8:15 
1F52:  MOVFF  118,FE9
1F56:  MOVFF  119,FEA
1F5A:  MOVFF  114,FEF
....................  
....................       //sidl 
....................       ptr--; 
1F5E:  MOVF   x18,W
1F60:  BTFSC  FD8.2
1F62:  DECF   x19,F
1F64:  DECF   x18,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
1F66:  MOVFF  118,FE9
1F6A:  MOVFF  119,FEA
1F6E:  MOVF   x15,W
1F70:  ANDLW  03
1F72:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
1F74:  MOVFF  118,FE9
1F78:  MOVFF  119,FEA
1F7C:  MOVFF  115,00
1F80:  RLCF   00,F
1F82:  RLCF   00,F
1F84:  RLCF   00,F
1F86:  MOVLW  F8
1F88:  ANDWF  00,F
1F8A:  MOVF   00,W
1F8C:  ANDLW  E0
1F8E:  IORWF  FEF,W
1F90:  MOVWF  FEF
....................       *ptr|=0x08; 
1F92:  MOVFF  118,FE9
1F96:  MOVFF  119,FEA
1F9A:  MOVF   FEF,W
1F9C:  IORLW  08
1F9E:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
1FA0:  MOVF   x18,W
1FA2:  BTFSC  FD8.2
1FA4:  DECF   x19,F
1FA6:  DECF   x18,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
1FA8:  MOVFF  118,FE9
1FAC:  MOVFF  119,FEA
1FB0:  MOVFF  115,00
1FB4:  SWAPF  00,F
1FB6:  RRCF   00,F
1FB8:  MOVLW  07
1FBA:  ANDWF  00,F
1FBC:  MOVF   00,W
1FBE:  ANDLW  07
1FC0:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
1FC2:  MOVFF  118,FE9
1FC6:  MOVFF  119,FEA
1FCA:  MOVFF  116,00
1FCE:  RLCF   00,F
1FD0:  RLCF   00,F
1FD2:  RLCF   00,F
1FD4:  MOVLW  F8
1FD6:  ANDWF  00,F
1FD8:  MOVF   00,W
1FDA:  ANDLW  F8
1FDC:  IORWF  FEF,W
1FDE:  MOVWF  FEF
....................    } 
....................    else {   //standard 
1FE0:  BRA    2060
....................       //eidl 
....................       *ptr=0; 
1FE2:  MOVFF  118,FE9
1FE6:  MOVFF  119,FEA
1FEA:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
1FEC:  MOVF   x18,W
1FEE:  BTFSC  FD8.2
1FF0:  DECF   x19,F
1FF2:  DECF   x18,F
....................       *ptr=0; 
1FF4:  MOVFF  118,FE9
1FF8:  MOVFF  119,FEA
1FFC:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
1FFE:  MOVF   x18,W
2000:  BTFSC  FD8.2
2002:  DECF   x19,F
2004:  DECF   x18,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
2006:  MOVFF  118,FE9
200A:  MOVFF  119,FEA
200E:  MOVFF  113,00
2012:  SWAPF  00,F
2014:  RLCF   00,F
2016:  MOVLW  E0
2018:  ANDWF  00,F
201A:  MOVF   00,W
201C:  ANDLW  E0
201E:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
2020:  MOVF   x18,W
2022:  BTFSC  FD8.2
2024:  DECF   x19,F
2026:  DECF   x18,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
2028:  MOVFF  118,FE9
202C:  MOVFF  119,FEA
2030:  MOVFF  113,00
2034:  RRCF   00,F
2036:  RRCF   00,F
2038:  RRCF   00,F
203A:  MOVLW  1F
203C:  ANDWF  00,F
203E:  MOVF   00,W
2040:  ANDLW  1F
2042:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
2044:  MOVFF  118,FE9
2048:  MOVFF  119,FEA
204C:  MOVFF  114,00
2050:  SWAPF  00,F
2052:  RLCF   00,F
2054:  MOVLW  E0
2056:  ANDWF  00,F
2058:  MOVF   00,W
205A:  ANDLW  E0
205C:  IORWF  FEF,W
205E:  MOVWF  FEF
....................    } 
.................... } 
2060:  MOVLB  0
2062:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
1592:  MOVLB  1
1594:  CLRF   x12
1596:  CLRF   x11
1598:  CLRF   x10
159A:  CLRF   x0F
....................    ptr=addr; 
159C:  MOVFF  10D,114
15A0:  MOVFF  10C,113
....................  
....................    if (ext) { 
15A4:  MOVF   x0E,F
15A6:  BTFSC  FD8.2
15A8:  BRA    16C0
....................       ret=*ptr;  //eidl 
15AA:  MOVFF  114,03
15AE:  MOVFF  113,FE9
15B2:  MOVFF  114,FEA
15B6:  MOVFF  FEF,00
15BA:  CLRF   01
15BC:  CLRF   02
15BE:  CLRF   03
15C0:  MOVFF  03,112
15C4:  MOVFF  02,111
15C8:  MOVFF  01,110
15CC:  MOVFF  00,10F
....................  
....................       ptr--;     //eidh 
15D0:  MOVF   x13,W
15D2:  BTFSC  FD8.2
15D4:  DECF   x14,F
15D6:  DECF   x13,F
....................       ret|=((int32)*ptr << 8); 
15D8:  MOVFF  113,FE9
15DC:  MOVFF  114,FEA
15E0:  MOVF   FEF,W
15E2:  CLRF   x17
15E4:  CLRF   x16
15E6:  MOVWF  x15
15E8:  CLRF   00
15EA:  MOVF   00,W
15EC:  IORWF  x0F,F
15EE:  MOVF   x15,W
15F0:  IORWF  x10,F
15F2:  MOVF   x16,W
15F4:  IORWF  x11,F
15F6:  MOVF   x17,W
15F8:  IORWF  x12,F
....................  
....................       ptr--;     //sidl 
15FA:  MOVF   x13,W
15FC:  BTFSC  FD8.2
15FE:  DECF   x14,F
1600:  DECF   x13,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
1602:  MOVFF  113,FE9
1606:  MOVFF  114,FEA
160A:  MOVF   FEF,W
160C:  ANDLW  03
160E:  MOVWF  x19
1610:  CLRF   x1A
1612:  CLRF   x1B
1614:  CLRF   x1C
1616:  CLRF   00
1618:  CLRF   01
161A:  MOVF   00,W
161C:  IORWF  x0F,F
161E:  MOVF   01,W
1620:  IORWF  x10,F
1622:  MOVF   x19,W
1624:  IORWF  x11,F
1626:  MOVF   x1A,W
1628:  IORWF  x12,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
162A:  MOVFF  113,FE9
162E:  MOVFF  114,FEA
1632:  MOVF   FEF,W
1634:  ANDLW  E0
1636:  MOVWF  x19
1638:  CLRF   x1A
163A:  CLRF   x1B
163C:  CLRF   x1C
163E:  CLRF   00
1640:  RLCF   x19,W
1642:  MOVWF  01
1644:  RLCF   x1A,W
1646:  MOVWF  02
1648:  RLCF   x1B,W
164A:  MOVWF  03
164C:  RLCF   01,F
164E:  RLCF   02,F
1650:  RLCF   03,F
1652:  RLCF   01,F
1654:  RLCF   02,F
1656:  RLCF   03,F
1658:  RLCF   01,F
165A:  RLCF   02,F
165C:  RLCF   03,F
165E:  RLCF   01,F
1660:  RLCF   02,F
1662:  RLCF   03,F
1664:  MOVLW  E0
1666:  ANDWF  01,F
1668:  MOVF   00,W
166A:  IORWF  x0F,F
166C:  MOVF   01,W
166E:  IORWF  x10,F
1670:  MOVF   02,W
1672:  IORWF  x11,F
1674:  MOVF   03,W
1676:  IORWF  x12,F
....................  
....................       ptr--;     //sidh 
1678:  MOVF   x13,W
167A:  BTFSC  FD8.2
167C:  DECF   x14,F
167E:  DECF   x13,F
....................       ret|=((int32)*ptr << 21); 
1680:  MOVFF  113,FE9
1684:  MOVFF  114,FEA
1688:  MOVF   FEF,W
168A:  CLRF   x16
168C:  MOVWF  x15
168E:  CLRF   00
1690:  CLRF   01
1692:  RLCF   x15,W
1694:  MOVWF  02
1696:  RLCF   x16,W
1698:  MOVWF  03
169A:  RLCF   02,F
169C:  RLCF   03,F
169E:  RLCF   02,F
16A0:  RLCF   03,F
16A2:  RLCF   02,F
16A4:  RLCF   03,F
16A6:  RLCF   02,F
16A8:  RLCF   03,F
16AA:  MOVLW  E0
16AC:  ANDWF  02,F
16AE:  MOVF   00,W
16B0:  IORWF  x0F,F
16B2:  MOVF   01,W
16B4:  IORWF  x10,F
16B6:  MOVF   02,W
16B8:  IORWF  x11,F
16BA:  MOVF   03,W
16BC:  IORWF  x12,F
....................  
....................    } 
....................    else { 
16BE:  BRA    175E
....................       ptr-=2;    //sidl 
16C0:  MOVLW  02
16C2:  SUBWF  x13,F
16C4:  MOVLW  00
16C6:  SUBWFB x14,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
16C8:  MOVFF  113,FE9
16CC:  MOVFF  114,FEA
16D0:  MOVF   FEF,W
16D2:  ANDLW  E0
16D4:  MOVWF  x19
16D6:  CLRF   x1A
16D8:  CLRF   x1B
16DA:  CLRF   x1C
16DC:  RRCF   x1C,W
16DE:  MOVWF  x12
16E0:  RRCF   x1B,W
16E2:  MOVWF  x11
16E4:  RRCF   x1A,W
16E6:  MOVWF  x10
16E8:  RRCF   x19,W
16EA:  MOVWF  x0F
16EC:  RRCF   x12,F
16EE:  RRCF   x11,F
16F0:  RRCF   x10,F
16F2:  RRCF   x0F,F
16F4:  RRCF   x12,F
16F6:  RRCF   x11,F
16F8:  RRCF   x10,F
16FA:  RRCF   x0F,F
16FC:  RRCF   x12,F
16FE:  RRCF   x11,F
1700:  RRCF   x10,F
1702:  RRCF   x0F,F
1704:  RRCF   x12,F
1706:  RRCF   x11,F
1708:  RRCF   x10,F
170A:  RRCF   x0F,F
170C:  MOVLW  07
170E:  ANDWF  x12,F
....................  
....................       ptr--;     //sidh 
1710:  MOVF   x13,W
1712:  BTFSC  FD8.2
1714:  DECF   x14,F
1716:  DECF   x13,F
....................       ret|=((int32)*ptr << 3); 
1718:  MOVFF  113,FE9
171C:  MOVFF  114,FEA
1720:  MOVF   FEF,W
1722:  CLRF   x18
1724:  CLRF   x17
1726:  CLRF   x16
1728:  MOVWF  x15
172A:  RLCF   x15,W
172C:  MOVWF  00
172E:  RLCF   x16,W
1730:  MOVWF  01
1732:  RLCF   x17,W
1734:  MOVWF  02
1736:  RLCF   x18,W
1738:  MOVWF  03
173A:  RLCF   00,F
173C:  RLCF   01,F
173E:  RLCF   02,F
1740:  RLCF   03,F
1742:  RLCF   00,F
1744:  RLCF   01,F
1746:  RLCF   02,F
1748:  RLCF   03,F
174A:  MOVLW  F8
174C:  ANDWF  00,F
174E:  MOVF   00,W
1750:  IORWF  x0F,F
1752:  MOVF   01,W
1754:  IORWF  x10,F
1756:  MOVF   02,W
1758:  IORWF  x11,F
175A:  MOVF   03,W
175C:  IORWF  x12,F
....................    } 
....................  
....................    return(ret); 
175E:  MOVFF  10F,00
1762:  MOVFF  110,01
1766:  MOVFF  111,02
176A:  MOVFF  112,03
.................... } 
176E:  MOVLB  0
1770:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
2064:  MOVLW  0F
2066:  MOVLB  1
2068:  MOVWF  x0F
206A:  MOVLW  66
206C:  MOVWF  x0E
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
206E:  MOVLB  F
2070:  BTFSC  x40.3
2072:  BRA    2084
....................       CANCON.win=CAN_WIN_TX0; 
2074:  MOVLW  F1
2076:  ANDWF  F6F,W
2078:  IORLW  08
207A:  MOVWF  F6F
....................       port=0; 
207C:  MOVLB  1
207E:  CLRF   x10
....................    } 
....................    else if (!TXB1CON.txreq) { 
2080:  BRA    20B8
2082:  MOVLB  F
2084:  BTFSC  x30.3
2086:  BRA    209A
....................       CANCON.win=CAN_WIN_TX1; 
2088:  MOVLW  F1
208A:  ANDWF  F6F,W
208C:  IORLW  06
208E:  MOVWF  F6F
....................       port=1; 
2090:  MOVLW  01
2092:  MOVLB  1
2094:  MOVWF  x10
....................    } 
....................    else if (!TXB2CON.txreq) { 
2096:  BRA    20B8
2098:  MOVLB  F
209A:  BTFSC  x20.3
209C:  BRA    20B0
....................       CANCON.win=CAN_WIN_TX2; 
209E:  MOVLW  F1
20A0:  ANDWF  F6F,W
20A2:  IORLW  04
20A4:  MOVWF  F6F
....................       port=2; 
20A6:  MOVLW  02
20A8:  MOVLB  1
20AA:  MOVWF  x10
....................    } 
....................    else { 
20AC:  BRA    20B8
20AE:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
20B0:  MOVLW  00
20B2:  MOVWF  01
20B4:  BRA    2130
20B6:  MOVLB  1
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
20B8:  MOVF   x0A,W
20BA:  ANDLW  03
20BC:  MOVWF  00
20BE:  MOVLW  FC
20C0:  ANDWF  F60,W
20C2:  IORWF  00,W
20C4:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
20C6:  MOVLW  0F
20C8:  MOVWF  x12
20CA:  MOVLW  64
20CC:  MOVWF  x11
20CE:  MOVFF  106,116
20D2:  MOVFF  105,115
20D6:  MOVFF  104,114
20DA:  MOVFF  103,113
20DE:  MOVFF  10B,117
20E2:  MOVLB  0
20E4:  RCALL  1F30
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
20E6:  MOVFF  109,F65
....................    TXBaDLC.rtr=rtr; 
20EA:  BCF    F65.6
20EC:  MOVLB  1
20EE:  BTFSC  x0C.0
20F0:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
20F2:  CLRF   x0D
20F4:  MOVF   x09,W
20F6:  SUBWF  x0D,W
20F8:  BC    2122
....................       *txd0=*data; 
20FA:  MOVFF  107,FE9
20FE:  MOVFF  108,FEA
2102:  MOVFF  FEF,113
2106:  MOVFF  10F,FEA
210A:  MOVFF  10E,FE9
210E:  MOVFF  113,FEF
....................       txd0++; 
2112:  INCF   x0E,F
2114:  BTFSC  FD8.2
2116:  INCF   x0F,F
....................       data++; 
2118:  INCF   x07,F
211A:  BTFSC  FD8.2
211C:  INCF   x08,F
....................     } 
211E:  INCF   x0D,F
2120:  BRA    20F4
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
2122:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
2124:  MOVLW  F1
2126:  ANDWF  F6F,W
2128:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
212A:  MOVLW  01
212C:  MOVWF  01
212E:  MOVLB  F
.................... } 
2130:  MOVLB  0
2132:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
1788:  BTFSS  F60.7
178A:  BRA    17BC
*
19EE:  BTFSS  F60.7
19F0:  BRA    1A22
....................         CANCON.win=CAN_WIN_RX0; 
*
178C:  MOVLW  F1
178E:  ANDWF  F6F,W
1790:  MOVWF  F6F
*
19F2:  MOVLW  F1
19F4:  ANDWF  F6F,W
19F6:  MOVWF  F6F
....................         stat.buffer=0; 
*
1792:  MOVLB  0
1794:  BCF    xF6.4
*
19F8:  MOVLB  0
19FA:  BCF    xF6.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
1796:  BCF    FA4.0
*
19FC:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
1798:  BCF    xF6.0
179A:  BTFSC  F74.7
179C:  BSF    xF6.0
*
19FE:  BCF    xF6.0
1A00:  BTFSC  F74.7
1A02:  BSF    xF6.0
....................         COMSTAT.rx0ovfl=0; 
*
179E:  BCF    F74.7
*
1A04:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
17A0:  BTFSS  F60.2
17A2:  BRA    17BA
*
1A06:  BTFSS  F60.2
1A08:  BRA    1A20
....................          stat.filthit=RXB0CON.filthit0; 
*
17A4:  MOVLW  00
17A6:  BTFSC  F60.0
17A8:  MOVLW  01
17AA:  ANDLW  07
17AC:  MOVWF  00
17AE:  BCF    FD8.0
17B0:  RLCF   00,F
17B2:  MOVLW  F1
17B4:  ANDWF  xF6,W
17B6:  IORWF  00,W
17B8:  MOVWF  xF6
*
1A0A:  MOVLW  00
1A0C:  BTFSC  F60.0
1A0E:  MOVLW  01
1A10:  ANDLW  07
1A12:  MOVWF  00
1A14:  BCF    FD8.0
1A16:  RLCF   00,F
1A18:  MOVLW  F1
1A1A:  ANDWF  xF6,W
1A1C:  IORWF  00,W
1A1E:  MOVWF  xF6
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
17BA:  BRA    17FC
17BC:  MOVLB  F
17BE:  BTFSS  x50.7
17C0:  BRA    17F4
*
1A20:  BRA    1A62
1A22:  MOVLB  F
1A24:  BTFSS  x50.7
1A26:  BRA    1A5A
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
17C2:  MOVLW  F1
17C4:  ANDWF  F6F,W
17C6:  IORLW  0A
17C8:  MOVWF  F6F
*
1A28:  MOVLW  F1
1A2A:  ANDWF  F6F,W
1A2C:  IORLW  0A
1A2E:  MOVWF  F6F
....................         stat.buffer=1; 
*
17CA:  MOVLB  0
17CC:  BSF    xF6.4
*
1A30:  MOVLB  0
1A32:  BSF    xF6.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
17CE:  BCF    FA4.1
*
1A34:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
17D0:  BCF    xF6.0
17D2:  BTFSC  F74.6
17D4:  BSF    xF6.0
*
1A36:  BCF    xF6.0
1A38:  BTFSC  F74.6
1A3A:  BSF    xF6.0
....................         COMSTAT.rx1ovfl=0; 
*
17D6:  BCF    F74.6
*
1A3C:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
17D8:  MOVLB  F
17DA:  MOVF   x50,W
17DC:  ANDLW  07
17DE:  ANDLW  07
17E0:  MOVWF  00
17E2:  BCF    FD8.0
17E4:  RLCF   00,F
17E6:  MOVLW  F1
17E8:  MOVLB  0
17EA:  ANDWF  xF6,W
17EC:  IORWF  00,W
17EE:  MOVWF  xF6
*
1A3E:  MOVLB  F
1A40:  MOVF   x50,W
1A42:  ANDLW  07
1A44:  ANDLW  07
1A46:  MOVWF  00
1A48:  BCF    FD8.0
1A4A:  RLCF   00,F
1A4C:  MOVLW  F1
1A4E:  MOVLB  0
1A50:  ANDWF  xF6,W
1A52:  IORWF  00,W
1A54:  MOVWF  xF6
....................     } 
....................     else { 
*
17F0:  BRA    17FC
17F2:  MOVLB  F
*
1A56:  BRA    1A62
1A58:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
17F4:  MOVLW  00
17F6:  MOVWF  01
17F8:  BRA    189A
17FA:  MOVLB  0
*
1A5A:  MOVLW  00
1A5C:  MOVWF  01
1A5E:  BRA    1B00
1A60:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
17FC:  MOVF   F65,W
17FE:  ANDLW  0F
1800:  MOVWF  xF5
*
1A62:  MOVF   F65,W
1A64:  ANDLW  0F
1A66:  MOVWF  xF5
....................     stat.rtr=RXBaDLC.rtr; 
*
1802:  BCF    xF6.5
1804:  BTFSC  F65.6
1806:  BSF    xF6.5
*
1A68:  BCF    xF6.5
1A6A:  BTFSC  F65.6
1A6C:  BSF    xF6.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
1808:  BCF    xF6.6
180A:  BTFSC  F62.3
180C:  BSF    xF6.6
*
1A6E:  BCF    xF6.6
1A70:  BTFSC  F62.3
1A72:  BSF    xF6.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
180E:  MOVLW  00
1810:  BTFSC  xF6.6
1812:  MOVLW  01
1814:  MOVLB  1
1816:  MOVWF  x05
1818:  MOVLW  0F
181A:  MOVWF  x0D
181C:  MOVLW  64
181E:  MOVWF  x0C
1820:  MOVFF  105,10E
1824:  MOVLB  0
1826:  RCALL  1592
1828:  MOVFF  03,F4
182C:  MOVFF  02,F3
1830:  MOVFF  01,F2
1834:  MOVFF  00,F1
*
1A74:  MOVLW  00
1A76:  BTFSC  xF6.6
1A78:  MOVLW  01
1A7A:  MOVLB  1
1A7C:  MOVWF  x05
1A7E:  MOVLW  0F
1A80:  MOVWF  x0D
1A82:  MOVLW  64
1A84:  MOVWF  x0C
1A86:  MOVFF  105,10E
1A8A:  MOVLB  0
1A8C:  RCALL  1592
1A8E:  MOVFF  03,F4
1A92:  MOVFF  02,F3
1A96:  MOVFF  01,F2
1A9A:  MOVFF  00,F1
....................  
....................     ptr = &TXRXBaD0; 
*
1838:  MOVLW  0F
183A:  MOVLB  1
183C:  MOVWF  x04
183E:  MOVLW  66
1840:  MOVWF  x03
*
1A9E:  MOVLW  0F
1AA0:  MOVLB  1
1AA2:  MOVWF  x04
1AA4:  MOVLW  66
1AA6:  MOVWF  x03
....................     for ( i = 0; i < len; i++ ) { 
*
1842:  CLRF   x02
1844:  MOVLB  0
1846:  MOVF   xF5,W
1848:  MOVLB  1
184A:  SUBWF  x02,W
184C:  BC    1876
*
1AA8:  CLRF   x02
1AAA:  MOVLB  0
1AAC:  MOVF   xF5,W
1AAE:  MOVLB  1
1AB0:  SUBWF  x02,W
1AB2:  BC    1ADC
....................         *data = *ptr; 
*
184E:  MOVFF  103,FE9
1852:  MOVFF  104,FEA
1856:  MOVFF  FEF,107
185A:  MOVFF  101,FEA
185E:  MOVFF  100,FE9
1862:  MOVFF  107,FEF
*
1AB4:  MOVFF  103,FE9
1AB8:  MOVFF  104,FEA
1ABC:  MOVFF  FEF,107
1AC0:  MOVFF  101,FEA
1AC4:  MOVFF  100,FE9
1AC8:  MOVFF  107,FEF
....................         data++; 
*
1866:  INCF   x00,F
1868:  BTFSC  FD8.2
186A:  INCF   x01,F
*
1ACC:  INCF   x00,F
1ACE:  BTFSC  FD8.2
1AD0:  INCF   x01,F
....................         ptr++; 
*
186C:  INCF   x03,F
186E:  BTFSC  FD8.2
1870:  INCF   x04,F
*
1AD2:  INCF   x03,F
1AD4:  BTFSC  FD8.2
1AD6:  INCF   x04,F
....................     } 
*
1872:  INCF   x02,F
1874:  BRA    1844
*
1AD8:  INCF   x02,F
1ADA:  BRA    1AAA
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
1876:  MOVLW  F1
1878:  ANDWF  F6F,W
187A:  MOVWF  F6F
*
1ADC:  MOVLW  F1
1ADE:  ANDWF  F6F,W
1AE0:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
187C:  MOVLB  0
187E:  BCF    xF6.7
1880:  BTFSC  FA4.7
1882:  BSF    xF6.7
*
1AE2:  MOVLB  0
1AE4:  BCF    xF6.7
1AE6:  BTFSC  FA4.7
1AE8:  BSF    xF6.7
....................     CAN_INT_IRXIF = 0; 
*
1884:  BCF    FA4.7
*
1AEA:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
1886:  BTFSS  xF6.4
1888:  BRA    1892
*
1AEC:  BTFSS  xF6.4
1AEE:  BRA    1AF8
....................       RXB1CON.rxful=0; 
*
188A:  MOVLB  F
188C:  BCF    x50.7
*
1AF0:  MOVLB  F
1AF2:  BCF    x50.7
....................     } 
....................     else { 
*
188E:  BRA    1896
1890:  MOVLB  0
*
1AF4:  BRA    1AFC
1AF6:  MOVLB  0
....................       RXB0CON.rxful=0; 
*
1892:  BCF    F60.7
1894:  MOVLB  F
*
1AF8:  BCF    F60.7
1AFA:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
1896:  MOVLW  01
1898:  MOVWF  01
*
1AFC:  MOVLW  01
1AFE:  MOVWF  01
1B00:  MOVLB  0
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #define CAN_RECEIVE_STACK_SIZE 1 
.................... int can_rspoint=-1; 
.................... int can_rstack [CAN_RECEIVE_STACK_SIZE] [14]; 
.................... int1 can_rsfull=FALSE; 
.................... #define can_receiver_full() can_rsfull 
.................... #define CAN_TRANSMIT_STACK_SIZE 8 
.................... int can_tspoint=-1; 
.................... int can_tstack [CAN_TRANSMIT_STACK_SIZE] [13]; 
.................... int1 can_tsempty=TRUE; 
.................... #define can_transmitter_empty() can_tsempty 
....................  
.................... void canReceive ( ) 
.................... { 
....................    int32 rx_id; 
....................    int8  rx_len, rx_stat; 
....................    int8  buffer [8]; 
....................    int8  i; 
....................  
....................    if(can_rspoint==-1) 
*
1772:  MOVF   31,W
1774:  SUBLW  FF
1776:  BNZ   177A
....................       can_rspoint++; 
1778:  INCF   31,F
....................  
....................    if(can_rspoint < CAN_RECEIVE_STACK_SIZE) 
177A:  MOVF   31,F
177C:  BTFSS  FD8.2
177E:  BRA    19E6
....................    { 
....................        
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
1780:  MOVLB  1
1782:  CLRF   x01
1784:  MOVLW  F7
1786:  MOVWF  x00
....................       can_rstack[can_rspoint][0]=make8(rx_id,3); 
*
189A:  MOVF   31,W
189C:  MULLW  0E
189E:  MOVF   FF3,W
18A0:  MOVLB  1
18A2:  CLRF   x01
18A4:  MOVWF  x00
18A6:  MOVLW  32
18A8:  ADDWF  x00,W
18AA:  MOVWF  FE9
18AC:  MOVLW  00
18AE:  ADDWFC x01,W
18B0:  MOVWF  FEA
18B2:  MOVLB  0
18B4:  MOVFF  F4,FEF
....................       can_rstack[can_rspoint][1]=make8(rx_id,2); 
18B8:  MOVF   31,W
18BA:  MULLW  0E
18BC:  MOVF   FF3,W
18BE:  MOVLB  1
18C0:  CLRF   x01
18C2:  MOVWF  x00
18C4:  MOVLW  01
18C6:  ADDWF  x00,W
18C8:  MOVWF  01
18CA:  MOVLW  00
18CC:  ADDWFC x01,W
18CE:  MOVWF  03
18D0:  MOVF   01,W
18D2:  ADDLW  32
18D4:  MOVWF  FE9
18D6:  MOVLW  00
18D8:  ADDWFC 03,W
18DA:  MOVWF  FEA
18DC:  MOVLB  0
18DE:  MOVFF  F3,FEF
....................       can_rstack[can_rspoint][2]=make8(rx_id,1); 
18E2:  MOVF   31,W
18E4:  MULLW  0E
18E6:  MOVF   FF3,W
18E8:  MOVLB  1
18EA:  CLRF   x01
18EC:  MOVWF  x00
18EE:  MOVLW  02
18F0:  ADDWF  x00,W
18F2:  MOVWF  01
18F4:  MOVLW  00
18F6:  ADDWFC x01,W
18F8:  MOVWF  03
18FA:  MOVF   01,W
18FC:  ADDLW  32
18FE:  MOVWF  FE9
1900:  MOVLW  00
1902:  ADDWFC 03,W
1904:  MOVWF  FEA
1906:  MOVLB  0
1908:  MOVFF  F2,FEF
....................       can_rstack[can_rspoint][3]=make8(rx_id,0); 
190C:  MOVF   31,W
190E:  MULLW  0E
1910:  MOVF   FF3,W
1912:  MOVLB  1
1914:  CLRF   x01
1916:  MOVWF  x00
1918:  MOVLW  03
191A:  ADDWF  x00,W
191C:  MOVWF  01
191E:  MOVLW  00
1920:  ADDWFC x01,W
1922:  MOVWF  03
1924:  MOVF   01,W
1926:  ADDLW  32
1928:  MOVWF  FE9
192A:  MOVLW  00
192C:  ADDWFC 03,W
192E:  MOVWF  FEA
1930:  MOVLB  0
1932:  MOVFF  F1,FEF
....................  
....................       can_rstack[can_rspoint][4]=rx_len; 
1936:  MOVF   31,W
1938:  MULLW  0E
193A:  MOVF   FF3,W
193C:  MOVLB  1
193E:  CLRF   x01
1940:  MOVWF  x00
1942:  MOVLW  04
1944:  ADDWF  x00,W
1946:  MOVWF  01
1948:  MOVLW  00
194A:  ADDWFC x01,W
194C:  MOVWF  03
194E:  MOVF   01,W
1950:  ADDLW  32
1952:  MOVWF  FE9
1954:  MOVLW  00
1956:  ADDWFC 03,W
1958:  MOVWF  FEA
195A:  MOVFF  F5,FEF
....................       can_rstack[can_rspoint][5]=rx_stat; 
195E:  MOVF   31,W
1960:  MULLW  0E
1962:  MOVF   FF3,W
1964:  CLRF   x01
1966:  MOVWF  x00
1968:  MOVLW  05
196A:  ADDWF  x00,W
196C:  MOVWF  01
196E:  MOVLW  00
1970:  ADDWFC x01,W
1972:  MOVWF  03
1974:  MOVF   01,W
1976:  ADDLW  32
1978:  MOVWF  FE9
197A:  MOVLW  00
197C:  ADDWFC 03,W
197E:  MOVWF  FEA
1980:  MOVFF  F6,FEF
....................  
....................       for(i=0;i<rx_len;i++) 
1984:  MOVLB  0
1986:  CLRF   xFF
1988:  MOVF   xF5,W
198A:  SUBWF  xFF,W
198C:  BC    19E2
....................       { 
....................          can_rstack[can_rspoint][i+6]=buffer[i]; 
198E:  MOVF   31,W
1990:  MULLW  0E
1992:  MOVF   FF3,W
1994:  MOVLB  1
1996:  CLRF   x01
1998:  MOVWF  x00
199A:  MOVLW  06
199C:  MOVLB  0
199E:  ADDWF  xFF,W
19A0:  CLRF   03
19A2:  MOVLB  1
19A4:  ADDWF  x00,W
19A6:  MOVWF  01
19A8:  MOVF   x01,W
19AA:  ADDWFC 03,F
19AC:  MOVF   01,W
19AE:  ADDLW  32
19B0:  MOVWF  01
19B2:  MOVLW  00
19B4:  ADDWFC 03,F
19B6:  MOVFF  03,104
19BA:  CLRF   03
19BC:  MOVLB  0
19BE:  MOVF   xFF,W
19C0:  ADDLW  F7
19C2:  MOVWF  FE9
19C4:  MOVLW  00
19C6:  ADDWFC 03,W
19C8:  MOVWF  FEA
19CA:  MOVFF  FEF,105
19CE:  MOVLB  1
19D0:  MOVFF  104,FEA
19D4:  MOVFF  01,FE9
19D8:  MOVFF  105,FEF
....................       } 
19DC:  MOVLB  0
19DE:  INCF   xFF,F
19E0:  BRA    1988
....................  
....................       can_rspoint++; 
19E2:  INCF   31,F
....................    } 
....................    else 
19E4:  BRA    1B00
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
19E6:  MOVLB  1
19E8:  CLRF   x01
19EA:  MOVLW  F7
19EC:  MOVWF  x00
.................... } 
*
1B02:  RETLW  00
....................  
....................  
.................... int1 can_Pop ( int32 & rx_id, int * buffer, int & rx_len, int & rx_stat ) 
.................... { 
....................    int i; 
....................  
....................    if(can_rspoint==CAN_RECEIVE_STACK_SIZE) 
*
1B5E:  DECFSZ 31,W
1B60:  BRA    1B64
*
3DF6:  DECFSZ 31,W
3DF8:  BRA    3DFC
....................       can_rspoint--; 
*
1B62:  DECF   31,F
*
3DFA:  DECF   31,F
....................  
....................    if(can_rspoint!=-1) 
*
1B64:  MOVF   31,W
1B66:  SUBLW  FF
1B68:  BTFSC  FD8.2
1B6A:  BRA    1CBE
*
3DFC:  MOVF   31,W
3DFE:  SUBLW  FF
3E00:  BTFSC  FD8.2
3E02:  BRA    3F56
....................    { 
....................       rx_id=make32(can_rstack[can_rspoint][0], 
....................                   can_rstack[can_rspoint][1], 
....................                   can_rstack[can_rspoint][2], 
....................                   can_rstack[can_rspoint][3]); 
*
1B6C:  MOVF   31,W
1B6E:  MULLW  0E
1B70:  MOVF   FF3,W
1B72:  CLRF   x06
1B74:  MOVWF  x05
1B76:  MOVLW  32
1B78:  ADDWF  x05,W
1B7A:  MOVWF  FE9
1B7C:  MOVLW  00
1B7E:  ADDWFC x06,W
1B80:  MOVWF  FEA
1B82:  MOVFF  FEF,107
1B86:  MOVF   31,W
1B88:  MULLW  0E
1B8A:  MOVF   FF3,W
1B8C:  CLRF   x09
1B8E:  MOVWF  x08
1B90:  MOVLW  01
1B92:  ADDWF  x08,W
1B94:  MOVWF  01
1B96:  MOVLW  00
1B98:  ADDWFC x09,W
1B9A:  MOVWF  03
1B9C:  MOVF   01,W
1B9E:  ADDLW  32
1BA0:  MOVWF  FE9
1BA2:  MOVLW  00
1BA4:  ADDWFC 03,W
1BA6:  MOVWF  FEA
1BA8:  MOVFF  FEF,10A
1BAC:  MOVF   31,W
1BAE:  MULLW  0E
1BB0:  MOVF   FF3,W
1BB2:  CLRF   x0C
1BB4:  MOVWF  x0B
1BB6:  MOVLW  02
1BB8:  ADDWF  x0B,W
1BBA:  MOVWF  01
1BBC:  MOVLW  00
1BBE:  ADDWFC x0C,W
1BC0:  MOVWF  03
1BC2:  MOVF   01,W
1BC4:  ADDLW  32
1BC6:  MOVWF  FE9
1BC8:  MOVLW  00
1BCA:  ADDWFC 03,W
1BCC:  MOVWF  FEA
1BCE:  MOVFF  FEF,10D
1BD2:  MOVF   31,W
1BD4:  MULLW  0E
1BD6:  MOVF   FF3,W
1BD8:  CLRF   x0F
1BDA:  MOVWF  x0E
1BDC:  MOVLW  03
1BDE:  ADDWF  x0E,W
1BE0:  MOVWF  01
1BE2:  MOVLW  00
1BE4:  ADDWFC x0F,W
1BE6:  MOVWF  03
1BE8:  MOVF   01,W
1BEA:  ADDLW  32
1BEC:  MOVWF  FE9
1BEE:  MOVLW  00
1BF0:  ADDWFC 03,W
1BF2:  MOVWF  FEA
1BF4:  MOVFF  FEF,110
1BF8:  MOVFF  107,F4
1BFC:  MOVFF  10A,F3
1C00:  MOVFF  10D,F2
1C04:  MOVFF  110,F1
*
3E04:  MOVF   31,W
3E06:  MULLW  0E
3E08:  MOVF   FF3,W
3E0A:  CLRF   x06
3E0C:  MOVWF  x05
3E0E:  MOVLW  32
3E10:  ADDWF  x05,W
3E12:  MOVWF  FE9
3E14:  MOVLW  00
3E16:  ADDWFC x06,W
3E18:  MOVWF  FEA
3E1A:  MOVFF  FEF,107
3E1E:  MOVF   31,W
3E20:  MULLW  0E
3E22:  MOVF   FF3,W
3E24:  CLRF   x09
3E26:  MOVWF  x08
3E28:  MOVLW  01
3E2A:  ADDWF  x08,W
3E2C:  MOVWF  01
3E2E:  MOVLW  00
3E30:  ADDWFC x09,W
3E32:  MOVWF  03
3E34:  MOVF   01,W
3E36:  ADDLW  32
3E38:  MOVWF  FE9
3E3A:  MOVLW  00
3E3C:  ADDWFC 03,W
3E3E:  MOVWF  FEA
3E40:  MOVFF  FEF,10A
3E44:  MOVF   31,W
3E46:  MULLW  0E
3E48:  MOVF   FF3,W
3E4A:  CLRF   x0C
3E4C:  MOVWF  x0B
3E4E:  MOVLW  02
3E50:  ADDWF  x0B,W
3E52:  MOVWF  01
3E54:  MOVLW  00
3E56:  ADDWFC x0C,W
3E58:  MOVWF  03
3E5A:  MOVF   01,W
3E5C:  ADDLW  32
3E5E:  MOVWF  FE9
3E60:  MOVLW  00
3E62:  ADDWFC 03,W
3E64:  MOVWF  FEA
3E66:  MOVFF  FEF,10D
3E6A:  MOVF   31,W
3E6C:  MULLW  0E
3E6E:  MOVF   FF3,W
3E70:  CLRF   x0F
3E72:  MOVWF  x0E
3E74:  MOVLW  03
3E76:  ADDWF  x0E,W
3E78:  MOVWF  01
3E7A:  MOVLW  00
3E7C:  ADDWFC x0F,W
3E7E:  MOVWF  03
3E80:  MOVF   01,W
3E82:  ADDLW  32
3E84:  MOVWF  FE9
3E86:  MOVLW  00
3E88:  ADDWFC 03,W
3E8A:  MOVWF  FEA
3E8C:  MOVFF  FEF,110
3E90:  MOVFF  107,BE
3E94:  MOVFF  10A,BD
3E98:  MOVFF  10D,BC
3E9C:  MOVFF  110,BB
....................  
....................       rx_len=can_rstack[can_rspoint][4]; 
*
1C08:  MOVF   31,W
1C0A:  MULLW  0E
1C0C:  MOVF   FF3,W
1C0E:  CLRF   x06
1C10:  MOVWF  x05
1C12:  MOVLW  04
1C14:  ADDWF  x05,W
1C16:  MOVWF  01
1C18:  MOVLW  00
1C1A:  ADDWFC x06,W
1C1C:  MOVWF  03
1C1E:  MOVF   01,W
1C20:  ADDLW  32
1C22:  MOVWF  FE9
1C24:  MOVLW  00
1C26:  ADDWFC 03,W
1C28:  MOVWF  FEA
1C2A:  MOVFF  FEF,F5
1C2E:  MOVLB  0
*
3EA0:  MOVF   31,W
3EA2:  MULLW  0E
3EA4:  MOVF   FF3,W
3EA6:  CLRF   x06
3EA8:  MOVWF  x05
3EAA:  MOVLW  04
3EAC:  ADDWF  x05,W
3EAE:  MOVWF  01
3EB0:  MOVLW  00
3EB2:  ADDWFC x06,W
3EB4:  MOVWF  03
3EB6:  MOVF   01,W
3EB8:  ADDLW  32
3EBA:  MOVWF  FE9
3EBC:  MOVLW  00
3EBE:  ADDWFC 03,W
3EC0:  MOVWF  FEA
3EC2:  MOVFF  FEF,B9
3EC6:  MOVLB  0
....................       rx_stat=can_rstack[can_rspoint][5]; 
*
1C30:  MOVF   31,W
1C32:  MULLW  0E
1C34:  MOVF   FF3,W
1C36:  MOVLB  1
1C38:  CLRF   x06
1C3A:  MOVWF  x05
1C3C:  MOVLW  05
1C3E:  ADDWF  x05,W
1C40:  MOVWF  01
1C42:  MOVLW  00
1C44:  ADDWFC x06,W
1C46:  MOVWF  03
1C48:  MOVF   01,W
1C4A:  ADDLW  32
1C4C:  MOVWF  FE9
1C4E:  MOVLW  00
1C50:  ADDWFC 03,W
1C52:  MOVWF  FEA
1C54:  MOVFF  FEF,F6
1C58:  MOVLB  0
*
3EC8:  MOVF   31,W
3ECA:  MULLW  0E
3ECC:  MOVF   FF3,W
3ECE:  MOVLB  1
3ED0:  CLRF   x06
3ED2:  MOVWF  x05
3ED4:  MOVLW  05
3ED6:  ADDWF  x05,W
3ED8:  MOVWF  01
3EDA:  MOVLW  00
3EDC:  ADDWFC x06,W
3EDE:  MOVWF  03
3EE0:  MOVF   01,W
3EE2:  ADDLW  32
3EE4:  MOVWF  FE9
3EE6:  MOVLW  00
3EE8:  ADDWFC 03,W
3EEA:  MOVWF  FEA
3EEC:  MOVFF  FEF,B8
3EF0:  MOVLB  0
....................  
....................       for(i=0;i<rx_len;i++) 
*
1C5A:  MOVLB  1
1C5C:  CLRF   x04
1C5E:  MOVLB  0
1C60:  MOVF   xF5,W
1C62:  MOVLB  1
1C64:  SUBWF  x04,W
1C66:  BC    1CB4
*
3EF2:  MOVLB  1
3EF4:  CLRF   x04
3EF6:  MOVLB  0
3EF8:  MOVF   xB9,W
3EFA:  MOVLB  1
3EFC:  SUBWF  x04,W
3EFE:  BC    3F4C
....................       { 
....................          buffer[i]=can_rstack[can_rspoint][i+6]; 
*
1C68:  CLRF   03
1C6A:  MOVF   x04,W
1C6C:  ADDWF  x02,W
1C6E:  MOVWF  01
1C70:  MOVF   x03,W
1C72:  ADDWFC 03,F
1C74:  MOVFF  01,105
1C78:  MOVFF  03,106
1C7C:  MOVF   31,W
1C7E:  MULLW  0E
1C80:  MOVF   FF3,W
1C82:  CLRF   x08
1C84:  MOVWF  x07
1C86:  MOVLW  06
1C88:  ADDWF  x04,W
1C8A:  CLRF   03
1C8C:  ADDWF  x07,W
1C8E:  MOVWF  01
1C90:  MOVF   x08,W
1C92:  ADDWFC 03,F
1C94:  MOVF   01,W
1C96:  ADDLW  32
1C98:  MOVWF  FE9
1C9A:  MOVLW  00
1C9C:  ADDWFC 03,W
1C9E:  MOVWF  FEA
1CA0:  MOVFF  FEF,10A
1CA4:  MOVFF  106,FEA
1CA8:  MOVFF  105,FE9
1CAC:  MOVFF  10A,FEF
*
3F00:  CLRF   03
3F02:  MOVF   x04,W
3F04:  ADDWF  x02,W
3F06:  MOVWF  01
3F08:  MOVF   x03,W
3F0A:  ADDWFC 03,F
3F0C:  MOVFF  01,105
3F10:  MOVFF  03,106
3F14:  MOVF   31,W
3F16:  MULLW  0E
3F18:  MOVF   FF3,W
3F1A:  CLRF   x08
3F1C:  MOVWF  x07
3F1E:  MOVLW  06
3F20:  ADDWF  x04,W
3F22:  CLRF   03
3F24:  ADDWF  x07,W
3F26:  MOVWF  01
3F28:  MOVF   x08,W
3F2A:  ADDWFC 03,F
3F2C:  MOVF   01,W
3F2E:  ADDLW  32
3F30:  MOVWF  FE9
3F32:  MOVLW  00
3F34:  ADDWFC 03,W
3F36:  MOVWF  FEA
3F38:  MOVFF  FEF,10A
3F3C:  MOVFF  106,FEA
3F40:  MOVFF  105,FE9
3F44:  MOVFF  10A,FEF
....................       } 
*
1CB0:  INCF   x04,F
1CB2:  BRA    1C5E
*
3F48:  INCF   x04,F
3F4A:  BRA    3EF6
....................       can_rspoint--; 
*
1CB4:  DECF   31,F
*
3F4C:  DECF   31,F
....................  
....................       return TRUE; 
*
1CB6:  MOVLW  01
1CB8:  MOVWF  01
1CBA:  BRA    1CC4
*
3F4E:  MOVLW  01
3F50:  MOVWF  01
3F52:  BRA    3F5C
....................    }    
....................    else 
*
1CBC:  BRA    1CC4
*
3F54:  BRA    3F5C
....................    return FALSE; 
*
1CBE:  MOVLW  00
1CC0:  MOVWF  01
1CC2:  BRA    1CC4
*
3F56:  MOVLW  00
3F58:  MOVWF  01
3F5A:  BRA    3F5C
.................... } 
....................  
....................  
.................... void canTransmit ( ) 
.................... { 
....................    int32 tx_id; 
....................    int8  tx_length; 
....................    int8  tx_priority; 
....................    int8  tx_buffer[8]; 
....................    int1  tx_extendedID; 
....................    int1  tx_emptyframe; 
....................    int8  i; 
....................     
....................    if(can_tspoint==CAN_TRANSMIT_STACK_SIZE) 
*
2134:  MOVF   40,W
2136:  SUBLW  08
2138:  BNZ   213C
....................    { 
....................       can_tspoint--; 
213A:  DECF   40,F
....................    } 
....................    if(can_tspoint!=-1) 
213C:  MOVF   40,W
213E:  SUBLW  FF
2140:  BTFSC  FD8.2
2142:  BRA    235A
....................    { 
....................       delay_ms(10); 
2144:  MOVLW  0A
2146:  MOVLB  1
2148:  MOVWF  x01
214A:  MOVLB  0
214C:  RCALL  1F02
....................       tx_id=make32(can_tstack[can_tspoint][0], 
....................                   can_tstack[can_tspoint][1], 
....................                   can_tstack[can_tspoint][2], 
....................                   can_tstack[can_tspoint][3]); 
214E:  MOVF   40,W
2150:  MULLW  0D
2152:  MOVF   FF3,W
2154:  MOVLB  1
2156:  CLRF   x02
2158:  MOVWF  x01
215A:  MOVLW  41
215C:  ADDWF  x01,W
215E:  MOVWF  FE9
2160:  MOVLW  00
2162:  ADDWFC x02,W
2164:  MOVWF  FEA
2166:  MOVFF  FEF,103
216A:  MOVF   40,W
216C:  MULLW  0D
216E:  MOVF   FF3,W
2170:  CLRF   x05
2172:  MOVWF  x04
2174:  MOVLW  01
2176:  ADDWF  x04,W
2178:  MOVWF  01
217A:  MOVLW  00
217C:  ADDWFC x05,W
217E:  MOVWF  03
2180:  MOVF   01,W
2182:  ADDLW  41
2184:  MOVWF  FE9
2186:  MOVLW  00
2188:  ADDWFC 03,W
218A:  MOVWF  FEA
218C:  MOVFF  FEF,106
2190:  MOVF   40,W
2192:  MULLW  0D
2194:  MOVF   FF3,W
2196:  CLRF   x08
2198:  MOVWF  x07
219A:  MOVLW  02
219C:  ADDWF  x07,W
219E:  MOVWF  01
21A0:  MOVLW  00
21A2:  ADDWFC x08,W
21A4:  MOVWF  03
21A6:  MOVF   01,W
21A8:  ADDLW  41
21AA:  MOVWF  FE9
21AC:  MOVLW  00
21AE:  ADDWFC 03,W
21B0:  MOVWF  FEA
21B2:  MOVFF  FEF,109
21B6:  MOVF   40,W
21B8:  MULLW  0D
21BA:  MOVF   FF3,W
21BC:  CLRF   x0B
21BE:  MOVWF  x0A
21C0:  MOVLW  03
21C2:  ADDWF  x0A,W
21C4:  MOVWF  01
21C6:  MOVLW  00
21C8:  ADDWFC x0B,W
21CA:  MOVWF  03
21CC:  MOVF   01,W
21CE:  ADDLW  41
21D0:  MOVWF  FE9
21D2:  MOVLW  00
21D4:  ADDWFC 03,W
21D6:  MOVWF  FEA
21D8:  MOVFF  FEF,10C
21DC:  MOVFF  103,F4
21E0:  MOVFF  106,F3
21E4:  MOVFF  109,F2
21E8:  MOVFF  10C,F1
....................  
....................       tx_length=can_tstack[can_tspoint][12]>>4; 
21EC:  MOVF   40,W
21EE:  MULLW  0D
21F0:  MOVF   FF3,W
21F2:  CLRF   x02
21F4:  MOVWF  x01
21F6:  MOVLW  0C
21F8:  ADDWF  x01,W
21FA:  MOVWF  01
21FC:  MOVLW  00
21FE:  ADDWFC x02,W
2200:  MOVWF  03
2202:  MOVF   01,W
2204:  ADDLW  41
2206:  MOVWF  FE9
2208:  MOVLW  00
220A:  ADDWFC 03,W
220C:  MOVWF  FEA
220E:  SWAPF  FEF,W
2210:  MOVLB  0
2212:  MOVWF  xF5
2214:  MOVLW  0F
2216:  ANDWF  xF5,F
....................       tx_priority=(can_tstack[can_tspoint][12]&0x0c)>>2; 
2218:  MOVF   40,W
221A:  MULLW  0D
221C:  MOVF   FF3,W
221E:  MOVLB  1
2220:  CLRF   x02
2222:  MOVWF  x01
2224:  MOVLW  0C
2226:  ADDWF  x01,W
2228:  MOVWF  01
222A:  MOVLW  00
222C:  ADDWFC x02,W
222E:  MOVWF  03
2230:  MOVF   01,W
2232:  ADDLW  41
2234:  MOVWF  FE9
2236:  MOVLW  00
2238:  ADDWFC 03,W
223A:  MOVWF  FEA
223C:  MOVF   FEF,W
223E:  ANDLW  0C
2240:  MOVWF  00
2242:  RRCF   00,W
2244:  MOVLB  0
2246:  MOVWF  xF6
2248:  RRCF   xF6,F
224A:  MOVLW  3F
224C:  ANDWF  xF6,F
....................       tx_extendedID=bit_test(can_tstack[can_tspoint][12],1); 
224E:  MOVF   40,W
2250:  MULLW  0D
2252:  MOVF   FF3,W
2254:  MOVLB  1
2256:  CLRF   x02
2258:  MOVWF  x01
225A:  MOVLW  0C
225C:  ADDWF  x01,W
225E:  MOVWF  01
2260:  MOVLW  00
2262:  ADDWFC x02,W
2264:  MOVWF  03
2266:  MOVF   01,W
2268:  ADDLW  41
226A:  MOVWF  FE9
226C:  MOVLW  00
226E:  ADDWFC 03,W
2270:  MOVWF  FEA
2272:  MOVFF  FEF,103
2276:  MOVLB  0
2278:  BCF    xFF.0
227A:  MOVLB  1
227C:  BTFSS  x03.1
227E:  BRA    2286
2280:  MOVLB  0
2282:  BSF    xFF.0
2284:  MOVLB  1
....................       tx_emptyframe=bit_test(can_tstack[can_tspoint][12],0); 
2286:  MOVF   40,W
2288:  MULLW  0D
228A:  MOVF   FF3,W
228C:  CLRF   x02
228E:  MOVWF  x01
2290:  MOVLW  0C
2292:  ADDWF  x01,W
2294:  MOVWF  01
2296:  MOVLW  00
2298:  ADDWFC x02,W
229A:  MOVWF  03
229C:  MOVF   01,W
229E:  ADDLW  41
22A0:  MOVWF  FE9
22A2:  MOVLW  00
22A4:  ADDWFC 03,W
22A6:  MOVWF  FEA
22A8:  MOVFF  FEF,103
22AC:  MOVLB  0
22AE:  BCF    xFF.1
22B0:  MOVLB  1
22B2:  BTFSS  x03.0
22B4:  BRA    22BC
22B6:  MOVLB  0
22B8:  BSF    xFF.1
22BA:  MOVLB  1
....................  
....................       for(i=0;i<tx_length;i++) 
22BC:  CLRF   x00
22BE:  MOVLB  0
22C0:  MOVF   xF5,W
22C2:  MOVLB  1
22C4:  SUBWF  x00,W
22C6:  BC    2314
....................       { 
....................          tx_buffer[i]=can_tstack[can_tspoint][i+4]; 
22C8:  CLRF   03
22CA:  MOVF   x00,W
22CC:  ADDLW  F7
22CE:  MOVWF  01
22D0:  MOVLW  00
22D2:  ADDWFC 03,F
22D4:  MOVFF  01,101
22D8:  MOVFF  03,102
22DC:  MOVF   40,W
22DE:  MULLW  0D
22E0:  MOVF   FF3,W
22E2:  CLRF   x04
22E4:  MOVWF  x03
22E6:  MOVLW  04
22E8:  ADDWF  x00,W
22EA:  CLRF   03
22EC:  ADDWF  x03,W
22EE:  MOVWF  01
22F0:  MOVF   x04,W
22F2:  ADDWFC 03,F
22F4:  MOVF   01,W
22F6:  ADDLW  41
22F8:  MOVWF  FE9
22FA:  MOVLW  00
22FC:  ADDWFC 03,W
22FE:  MOVWF  FEA
2300:  MOVFF  FEF,106
2304:  MOVFF  102,FEA
2308:  MOVFF  101,FE9
230C:  MOVFF  106,FEF
....................       } 
2310:  INCF   x00,F
2312:  BRA    22BE
....................  
....................       can_putd(tx_id,tx_buffer,tx_length,tx_priority,tx_extendedID,tx_emptyframe); 
2314:  MOVLW  00
2316:  MOVLB  0
2318:  BTFSC  xFF.0
231A:  MOVLW  01
231C:  MOVLB  1
231E:  MOVWF  x01
2320:  MOVLW  00
2322:  MOVLB  0
2324:  BTFSC  xFF.1
2326:  MOVLW  01
2328:  MOVLB  1
232A:  MOVWF  x02
232C:  MOVFF  F4,106
2330:  MOVFF  F3,105
2334:  MOVFF  F2,104
2338:  MOVFF  F1,103
233C:  CLRF   x08
233E:  MOVLW  F7
2340:  MOVWF  x07
2342:  MOVFF  F5,109
2346:  MOVFF  F6,10A
234A:  MOVFF  101,10B
234E:  MOVFF  102,10C
2352:  MOVLB  0
2354:  RCALL  2064
....................  
....................       can_tspoint--; 
2356:  DECF   40,F
....................    } 
....................    else 
2358:  BRA    235C
....................       return; 
235A:  BRA    235C
.................... } 
235C:  RETLW  00
....................  
....................  
.................... int1 can_push (int32 tx_id, int8 * tx_buffer, int8 tx_length, int8 tx_priority, int1 tx_extendedID, int1 tx_emptyframe) 
.................... { 
....................    int8  i; 
....................     
....................   /* if(can_tspoint==-1) 
....................       can_tspoint++;*/ 
....................  
....................    if(can_tspoint+1 < CAN_TRANSMIT_STACK_SIZE) 
*
32AE:  MOVLW  01
32B0:  ADDWF  40,W
32B2:  SUBLW  07
32B4:  BTFSS  FD8.0
32B6:  BRA    33E6
....................    { 
....................       
....................       can_tstack[can_tspoint+1][0]=make8(tx_id,3); 
32B8:  MOVLW  01
32BA:  ADDWF  40,W
32BC:  MULLW  0D
32BE:  MOVF   FF3,W
32C0:  CLRF   xE4
32C2:  MOVWF  xE3
32C4:  MOVLW  41
32C6:  ADDWF  xE3,W
32C8:  MOVWF  FE9
32CA:  MOVLW  00
32CC:  ADDWFC xE4,W
32CE:  MOVWF  FEA
32D0:  MOVFF  DA,FEF
....................       can_tstack[can_tspoint+1][1]=make8(tx_id,2); 
32D4:  MOVLW  01
32D6:  ADDWF  40,W
32D8:  MULLW  0D
32DA:  MOVF   FF3,W
32DC:  CLRF   xE4
32DE:  MOVWF  xE3
32E0:  MOVLW  01
32E2:  ADDWF  xE3,W
32E4:  MOVWF  01
32E6:  MOVLW  00
32E8:  ADDWFC xE4,W
32EA:  MOVWF  03
32EC:  MOVF   01,W
32EE:  ADDLW  41
32F0:  MOVWF  FE9
32F2:  MOVLW  00
32F4:  ADDWFC 03,W
32F6:  MOVWF  FEA
32F8:  MOVFF  D9,FEF
....................       can_tstack[can_tspoint+1][2]=make8(tx_id,1); 
32FC:  MOVLW  01
32FE:  ADDWF  40,W
3300:  MULLW  0D
3302:  MOVF   FF3,W
3304:  CLRF   xE4
3306:  MOVWF  xE3
3308:  MOVLW  02
330A:  ADDWF  xE3,W
330C:  MOVWF  01
330E:  MOVLW  00
3310:  ADDWFC xE4,W
3312:  MOVWF  03
3314:  MOVF   01,W
3316:  ADDLW  41
3318:  MOVWF  FE9
331A:  MOVLW  00
331C:  ADDWFC 03,W
331E:  MOVWF  FEA
3320:  MOVFF  D8,FEF
....................       can_tstack[can_tspoint+1][3]=make8(tx_id,0); 
3324:  MOVLW  01
3326:  ADDWF  40,W
3328:  MULLW  0D
332A:  MOVF   FF3,W
332C:  CLRF   xE4
332E:  MOVWF  xE3
3330:  MOVLW  03
3332:  ADDWF  xE3,W
3334:  MOVWF  01
3336:  MOVLW  00
3338:  ADDWFC xE4,W
333A:  MOVWF  03
333C:  MOVF   01,W
333E:  ADDLW  41
3340:  MOVWF  FE9
3342:  MOVLW  00
3344:  ADDWFC 03,W
3346:  MOVWF  FEA
3348:  MOVFF  D7,FEF
....................  
....................       for(i=0;i<tx_length;i++) 
334C:  CLRF   xE1
334E:  MOVF   xDD,W
3350:  SUBWF  xE1,W
3352:  BC    339E
....................       { 
....................          can_tstack[can_tspoint+1][i+4]=tx_buffer[i]; 
3354:  MOVLW  01
3356:  ADDWF  40,W
3358:  MULLW  0D
335A:  MOVF   FF3,W
335C:  CLRF   xE4
335E:  MOVWF  xE3
3360:  MOVLW  04
3362:  ADDWF  xE1,W
3364:  CLRF   03
3366:  ADDWF  xE3,W
3368:  MOVWF  01
336A:  MOVF   xE4,W
336C:  ADDWFC 03,F
336E:  MOVF   01,W
3370:  ADDLW  41
3372:  MOVWF  01
3374:  MOVLW  00
3376:  ADDWFC 03,F
3378:  MOVFF  03,E7
337C:  CLRF   03
337E:  MOVF   xE1,W
3380:  ADDWF  xDB,W
3382:  MOVWF  FE9
3384:  MOVF   xDC,W
3386:  ADDWFC 03,W
3388:  MOVWF  FEA
338A:  MOVFF  FEF,E8
338E:  MOVFF  E7,FEA
3392:  MOVFF  01,FE9
3396:  MOVFF  E8,FEF
....................       } 
339A:  INCF   xE1,F
339C:  BRA    334E
....................  
....................       can_tstack[can_tspoint+1][12]=(tx_length<<4)|(tx_priority<<2)|((int8)tx_extendedID<<1)|((int8)tx_emptyframe); 
339E:  MOVLW  01
33A0:  ADDWF  40,W
33A2:  MULLW  0D
33A4:  MOVF   FF3,W
33A6:  CLRF   xE4
33A8:  MOVWF  xE3
33AA:  MOVLW  0C
33AC:  ADDWF  xE3,W
33AE:  MOVWF  01
33B0:  MOVLW  00
33B2:  ADDWFC xE4,W
33B4:  MOVWF  03
33B6:  MOVF   01,W
33B8:  ADDLW  41
33BA:  MOVWF  FE9
33BC:  MOVLW  00
33BE:  ADDWFC 03,W
33C0:  MOVWF  FEA
33C2:  SWAPF  xDD,W
33C4:  MOVWF  xE7
33C6:  MOVLW  F0
33C8:  ANDWF  xE7,F
33CA:  RLCF   xDE,W
33CC:  MOVWF  00
33CE:  RLCF   00,F
33D0:  MOVLW  FC
33D2:  ANDWF  00,F
33D4:  MOVF   00,W
33D6:  IORWF  xE7,W
33D8:  MOVWF  xE8
33DA:  BCF    FD8.0
33DC:  RLCF   xDF,W
33DE:  IORWF  xE8,W
33E0:  IORWF  xE0,W
33E2:  MOVWF  FEF
....................  
....................        can_tspoint++; 
33E4:  INCF   40,F
....................    } 
.................... } 
33E6:  RETLW  00
....................  
....................  
.................... #int_canrx0 
.................... void canrx0_int ( ) { 
....................    if(DEBUG_MODE==D_RS232)  
*
1EAA:  DECFSZ 2F,W
1EAC:  BRA    1ECE
....................    { 
....................    printf("Can Message Received processing on canrx0_int\n\r"); 
1EAE:  CLRF   xF1
1EB0:  MOVF   xF1,W
1EB2:  CALL   0B5A
1EB6:  INCF   xF1,F
1EB8:  MOVWF  00
1EBA:  CLRWDT
1EBC:  BTFSS  F9E.4
1EBE:  BRA    1EBA
1EC0:  MOVWF  FAD
1EC2:  MOVLW  2F
1EC4:  SUBWF  xF1,W
1EC6:  BNZ   1EB0
....................    canReceive ( ); 
1EC8:  RCALL  1772
....................    printCAN(); 
1ECA:  RCALL  1B4E
....................    } 
....................    else canReceive ( ); 
1ECC:  BRA    1ED0
1ECE:  RCALL  1772
....................    // TODO: add CAN recieve code here 
.................... } 
1ED0:  BCF    FA4.0
1ED2:  GOTO   00C4
.................... #int_canrx1 
.................... void canrx1_int ( ) { 
....................     if(DEBUG_MODE==D_RS232)  
1ED6:  DECFSZ 2F,W
1ED8:  BRA    1EFA
....................    { 
....................    printf("Can Message Received processing on canrx1_int\n\r"); 
1EDA:  CLRF   xF1
1EDC:  MOVF   xF1,W
1EDE:  CALL   0B9A
1EE2:  INCF   xF1,F
1EE4:  MOVWF  00
1EE6:  CLRWDT
1EE8:  BTFSS  F9E.4
1EEA:  BRA    1EE6
1EEC:  MOVWF  FAD
1EEE:  MOVLW  2F
1EF0:  SUBWF  xF1,W
1EF2:  BNZ   1EDC
....................    canReceive ( ); 
1EF4:  RCALL  1772
....................    printCAN(); 
1EF6:  RCALL  1B4E
....................    } 
....................    else canReceive ( ); 
1EF8:  BRA    1EFC
1EFA:  RCALL  1772
....................    // TODO: add CAN recieve code here 
.................... } 
1EFC:  BCF    FA4.1
1EFE:  GOTO   00C4
.................... #int_cantx0 
.................... void cantx0_int ( ) { 
....................    canTransmit ( ); 
*
235E:  RCALL  2134
....................    // TODO: add CAN transmit code here 
.................... } 
2360:  BCF    FA4.2
2362:  GOTO   00C4
.................... #int_cantx1 
.................... void cantx1_int ( ) { 
....................    canTransmit ( ); 
2366:  RCALL  2134
....................    // TODO: add CAN transmit code here 
.................... } 
2368:  BCF    FA4.3
236A:  GOTO   00C4
.................... #int_cantx2 
.................... void cantx2_int ( ) { 
....................    canTransmit ( ); 
236E:  RCALL  2134
....................    // TODO: add CAN transmit code here 
.................... } 
2370:  BCF    FA4.4
2372:  GOTO   00C4
.................... #int_canirx 
.................... void canirx_int ( ) { 
....................  if(DEBUG_MODE==D_RS232)  
2376:  DECFSZ 2F,W
2378:  BRA    2394
....................    { 
....................    printf("Can IRX Received processing on canirx_int\n\r"); 
237A:  CLRF   xF1
237C:  MOVF   xF1,W
237E:  CALL   0BDA
2382:  INCF   xF1,F
2384:  MOVWF  00
2386:  CLRWDT
2388:  BTFSS  F9E.4
238A:  BRA    2386
238C:  MOVWF  FAD
238E:  MOVLW  2B
2390:  SUBWF  xF1,W
2392:  BNZ   237C
....................     
....................    } 
....................    // TODO: add CAN IRX handling code here 
.................... } 
2394:  BCF    FA4.7
2396:  GOTO   00C4
.................... #int_canerr 
.................... void canerr_int ( ) { 
....................   if(DEBUG_MODE==D_RS232)  
239A:  DECFSZ 2F,W
239C:  BRA    23B8
....................    { 
....................       printf("Can ERROR Received processing on canerr_int\n\r"); 
239E:  CLRF   xF1
23A0:  MOVF   xF1,W
23A2:  CALL   0C16
23A6:  INCF   xF1,F
23A8:  MOVWF  00
23AA:  CLRWDT
23AC:  BTFSS  F9E.4
23AE:  BRA    23AA
23B0:  MOVWF  FAD
23B2:  MOVLW  2D
23B4:  SUBWF  xF1,W
23B6:  BNZ   23A0
....................    } 
....................  // TODO: add CAN error handling code here 
.................... } 
23B8:  BCF    FA4.5
23BA:  GOTO   00C4
.................... void main() 
.................... { 
*
38E0:  CLRF   FF8
38E2:  BCF    FD0.7
38E4:  BSF    0D.7
38E6:  CLRF   FEA
38E8:  CLRF   FE9
38EA:  BSF    FB8.3
38EC:  MOVLW  08
38EE:  MOVWF  FAF
38F0:  MOVLW  02
38F2:  MOVWF  FB0
38F4:  MOVLW  A6
38F6:  MOVWF  FAC
38F8:  MOVLW  90
38FA:  MOVWF  FAB
38FC:  MOVF   FC1,W
38FE:  ANDLW  C0
3900:  IORLW  0F
3902:  MOVWF  FC1
3904:  CLRF   19
3906:  CLRF   1A
3908:  CLRF   1F
390A:  MOVLW  FF
390C:  MOVWF  31
390E:  BCF    22.1
3910:  MOVWF  40
3912:  BSF    22.2
....................    long timeout; 
....................     
....................    int BRP,PRSEG,PHSEG1,PHSEG2,SJW,SEG2PHTS; 
....................    char mc; 
....................    int rbuffer[6],stat,lenght,aux; 
....................    int32 send_id; 
....................    int16 au16; 
....................     
....................    
....................    printf("Last Reset Cause:%X\r\n",restart_cause()); 
3914:  MOVF   FD0,W
3916:  ANDLW  0F
3918:  BTFSS  FD0.4
391A:  MOVLW  00
391C:  BSF    FD0.0
391E:  BSF    FD0.1
3920:  BSF    FD0.4
3922:  BSF    FD8.3
3924:  BSF    FD8.4
3926:  MOVWF  xC1
3928:  CLRF   xC2
392A:  MOVF   xC2,W
392C:  CALL   0C54
3930:  INCF   xC2,F
3932:  MOVWF  00
3934:  CLRWDT
3936:  BTFSS  F9E.4
3938:  BRA    3934
393A:  MOVWF  FAD
393C:  MOVLW  11
393E:  SUBWF  xC2,W
3940:  BNZ   392A
3942:  CLRF   18
3944:  BTFSC  FF2.7
3946:  BSF    18.7
3948:  BCF    FF2.7
394A:  MOVFF  C1,102
394E:  MOVLW  37
3950:  MOVLB  1
3952:  MOVWF  x03
3954:  MOVLB  0
3956:  CALL   1B04
395A:  BTFSC  18.7
395C:  BSF    FF2.7
395E:  MOVLW  0D
3960:  CLRWDT
3962:  BTFSS  F9E.4
3964:  BRA    3960
3966:  MOVWF  FAD
3968:  MOVLW  0A
396A:  CLRWDT
396C:  BTFSS  F9E.4
396E:  BRA    396A
3970:  MOVWF  FAD
....................    printf("\n\r Module Starting PRESS D TO DEBUG, C TO CONFIGURE...\n\r"); 
3972:  CLRF   xC1
3974:  MOVF   xC1,W
3976:  CALL   0C84
397A:  INCF   xC1,F
397C:  MOVWF  00
397E:  CLRWDT
3980:  BTFSS  F9E.4
3982:  BRA    397E
3984:  MOVWF  FAD
3986:  MOVLW  38
3988:  SUBWF  xC1,W
398A:  BNZ   3974
....................     
....................    DEBUG_MODE=NODEBUG; 
398C:  CLRF   2F
....................    remote=0; 
398E:  BCF    22.0
....................    timeout=0; 
3990:  CLRF   xAA
3992:  CLRF   xA9
....................    while(!kbhit()&&(++timeout<20000)) delay_us(100); 
3994:  BTFSC  F9E.5
3996:  BRA    39B8
3998:  INCF   xA9,F
399A:  BTFSC  FD8.2
399C:  INCF   xAA,F
399E:  MOVF   xAA,W
39A0:  SUBLW  4E
39A2:  BNC   39B8
39A4:  BNZ   39AC
39A6:  MOVF   xA9,W
39A8:  SUBLW  1F
39AA:  BNC   39B8
39AC:  CLRWDT
39AE:  MOVLW  A6
39B0:  MOVWF  00
39B2:  DECFSZ 00,F
39B4:  BRA    39B2
39B6:  BRA    3994
....................    if(kbhit()) 
39B8:  BTFSS  F9E.5
39BA:  BRA    39FA
....................    { 
....................           mc=getc(); 
39BC:  CLRWDT
39BE:  BTFSS  F9E.5
39C0:  BRA    39BC
39C2:  MOVFF  FAE,B1
....................           if(mc=='d') DEBUG_MODE=D_RS232; 
39C6:  MOVF   xB1,W
39C8:  SUBLW  64
39CA:  BNZ   39D2
39CC:  MOVLW  01
39CE:  MOVWF  2F
....................           else if(mc=='c') configure(); 
39D0:  BRA    39DC
39D2:  MOVF   xB1,W
39D4:  SUBLW  63
39D6:  BNZ   39DC
39D8:  GOTO   25A4
....................            
....................           printf("\n\r Starting in Debug Mode PRESS C FOR CONSOLE\n\r"); 
39DC:  CLRF   xC1
39DE:  MOVF   xC1,W
39E0:  CALL   0CD8
39E4:  INCF   xC1,F
39E6:  MOVWF  00
39E8:  CLRWDT
39EA:  BTFSS  F9E.4
39EC:  BRA    39E8
39EE:  MOVWF  FAD
39F0:  MOVLW  2F
39F2:  SUBWF  xC1,W
39F4:  BNZ   39DE
....................           enable_interrupts(INT_RDA); 
39F6:  BSF    F9D.5
....................    } 
....................    else  
39F8:  BRA    3A14
....................    { 
....................           printf("\n\r Starting in Normal Mode \n\r"); 
39FA:  CLRF   xC1
39FC:  MOVF   xC1,W
39FE:  CALL   0D22
3A02:  INCF   xC1,F
3A04:  MOVWF  00
3A06:  CLRWDT
3A08:  BTFSS  F9E.4
3A0A:  BRA    3A06
3A0C:  MOVWF  FAD
3A0E:  MOVLW  1D
3A10:  SUBWF  xC1,W
3A12:  BNZ   39FC
....................    } 
....................  
....................  
....................  
....................  
....................     
....................    can_init(); 
3A14:  GOTO   312A
....................     
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
3A18:  MOVLW  04
3A1A:  MOVWF  xC1
3A1C:  CALL   30D8
....................     
....................    write_EEPROM(DEV_ID,10);//novos codigos para identificar o device 
3A20:  CLRF   FA9
3A22:  MOVLW  0A
3A24:  MOVWF  FA8
3A26:  BCF    FA6.6
3A28:  BCF    FA6.7
3A2A:  BSF    FA6.2
3A2C:  MOVFF  FF2,00
3A30:  BCF    FF2.7
3A32:  MOVLB  F
3A34:  MOVLW  55
3A36:  MOVWF  FA7
3A38:  MOVLW  AA
3A3A:  MOVWF  FA7
3A3C:  BSF    FA6.1
3A3E:  BTFSC  FA6.1
3A40:  BRA    3A3E
3A42:  BCF    FA6.2
3A44:  MOVF   00,W
3A46:  IORWF  FF2,F
....................    BRP=read_EEPROM(EBRP); 
3A48:  MOVFF  FF2,C1
3A4C:  BCF    FF2.7
3A4E:  MOVLW  07
3A50:  MOVWF  FA9
3A52:  BCF    FA6.6
3A54:  BCF    FA6.7
3A56:  BSF    FA6.0
3A58:  MOVF   FA8,W
3A5A:  MOVLB  0
3A5C:  BTFSC  xC1.7
3A5E:  BSF    FF2.7
3A60:  MOVWF  xAB
....................    PRSEG=read_EEPROM(EPRSEG); 
3A62:  MOVFF  FF2,C1
3A66:  BCF    FF2.7
3A68:  MOVLW  03
3A6A:  MOVWF  FA9
3A6C:  BCF    FA6.6
3A6E:  BCF    FA6.7
3A70:  BSF    FA6.0
3A72:  MOVF   FA8,W
3A74:  BTFSC  xC1.7
3A76:  BSF    FF2.7
3A78:  MOVWF  xAC
....................    PHSEG1=read_EEPROM(EPHSEG1); 
3A7A:  MOVFF  FF2,C1
3A7E:  BCF    FF2.7
3A80:  MOVLW  01
3A82:  MOVWF  FA9
3A84:  BCF    FA6.6
3A86:  BCF    FA6.7
3A88:  BSF    FA6.0
3A8A:  MOVF   FA8,W
3A8C:  BTFSC  xC1.7
3A8E:  BSF    FF2.7
3A90:  MOVWF  xAD
....................    PHSEG2=read_EEPROM(EPHSEG2); 
3A92:  MOVFF  FF2,C1
3A96:  BCF    FF2.7
3A98:  MOVLW  02
3A9A:  MOVWF  FA9
3A9C:  BCF    FA6.6
3A9E:  BCF    FA6.7
3AA0:  BSF    FA6.0
3AA2:  MOVF   FA8,W
3AA4:  BTFSC  xC1.7
3AA6:  BSF    FF2.7
3AA8:  MOVWF  xAE
....................    ADRESS=read_EEPROM(EADRESS); 
3AAA:  MOVFF  FF2,C1
3AAE:  BCF    FF2.7
3AB0:  MOVLW  04
3AB2:  MOVWF  FA9
3AB4:  BCF    FA6.6
3AB6:  BCF    FA6.7
3AB8:  BSF    FA6.0
3ABA:  MOVF   FA8,W
3ABC:  BTFSC  xC1.7
3ABE:  BSF    FF2.7
3AC0:  MOVWF  23
....................    SJW=read_EEPROM(ESJW); 
3AC2:  MOVFF  FF2,C1
3AC6:  BCF    FF2.7
3AC8:  MOVLW  06
3ACA:  MOVWF  FA9
3ACC:  BCF    FA6.6
3ACE:  BCF    FA6.7
3AD0:  BSF    FA6.0
3AD2:  MOVF   FA8,W
3AD4:  BTFSC  xC1.7
3AD6:  BSF    FF2.7
3AD8:  MOVWF  xAF
....................    SEG2PHTS=read_EEPROM(ESEG2PHTS); 
3ADA:  MOVFF  FF2,C1
3ADE:  BCF    FF2.7
3AE0:  MOVLW  05
3AE2:  MOVWF  FA9
3AE4:  BCF    FA6.6
3AE6:  BCF    FA6.7
3AE8:  BSF    FA6.0
3AEA:  MOVF   FA8,W
3AEC:  BTFSC  xC1.7
3AEE:  BSF    FF2.7
3AF0:  MOVWF  xB0
....................     
....................    if(BRP==0xFF) 
3AF2:  INCFSZ xAB,W
3AF4:  BRA    3B24
....................    { 
....................    printf("Loading CAN defaults\n\r"); 
3AF6:  CLRF   xC1
3AF8:  MOVF   xC1,W
3AFA:  CALL   0D5A
3AFE:  INCF   xC1,F
3B00:  MOVWF  00
3B02:  CLRWDT
3B04:  BTFSS  F9E.4
3B06:  BRA    3B02
3B08:  MOVWF  FAD
3B0A:  MOVLW  16
3B0C:  SUBWF  xC1,W
3B0E:  BNZ   3AF8
....................    BRP=0; 
3B10:  CLRF   xAB
....................    SJW=0; 
3B12:  CLRF   xAF
....................    PRSEG=1; 
3B14:  MOVLW  01
3B16:  MOVWF  xAC
....................    PHSEG1=2; 
3B18:  MOVLW  02
3B1A:  MOVWF  xAD
....................    SEG2PHTS=true; 
3B1C:  MOVLW  01
3B1E:  MOVWF  xB0
....................    PHSEG2=2; 
3B20:  MOVLW  02
3B22:  MOVWF  xAE
....................    } 
....................    if(ADRESS==0xFF) 
3B24:  INCFSZ 23,W
3B26:  BRA    3B46
....................    { 
....................    printf("Adress not Set Loading default ADR 30\n\r"); 
3B28:  CLRF   xC1
3B2A:  MOVF   xC1,W
3B2C:  CALL   0D8C
3B30:  INCF   xC1,F
3B32:  MOVWF  00
3B34:  CLRWDT
3B36:  BTFSS  F9E.4
3B38:  BRA    3B34
3B3A:  MOVWF  FAD
3B3C:  MOVLW  27
3B3E:  SUBWF  xC1,W
3B40:  BNZ   3B2A
....................    ADRESS=0x30; 
3B42:  MOVLW  30
3B44:  MOVWF  23
....................    } 
....................    
....................    switch_modes=read_eeprom(20); 
3B46:  MOVFF  FF2,C1
3B4A:  BCF    FF2.7
3B4C:  MOVLW  14
3B4E:  MOVWF  FA9
3B50:  BCF    FA6.6
3B52:  BCF    FA6.7
3B54:  BSF    FA6.0
3B56:  MOVF   FA8,W
3B58:  BTFSC  xC1.7
3B5A:  BSF    FF2.7
3B5C:  MOVWF  26
....................    for(x=0;x<8;++x) 
3B5E:  CLRF   21
3B60:  MOVF   21,W
3B62:  SUBLW  07
3B64:  BNC   3B96
....................    { 
....................       what_control_what[x]=read_EEPROM(10+x); 
3B66:  CLRF   03
3B68:  MOVF   21,W
3B6A:  ADDLW  27
3B6C:  MOVWF  FE9
3B6E:  MOVLW  00
3B70:  ADDWFC 03,W
3B72:  MOVWF  FEA
3B74:  MOVLW  0A
3B76:  ADDWF  21,W
3B78:  MOVWF  xC3
3B7A:  MOVFF  FF2,C4
3B7E:  BCF    FF2.7
3B80:  MOVFF  C3,FA9
3B84:  BCF    FA6.6
3B86:  BCF    FA6.7
3B88:  BSF    FA6.0
3B8A:  MOVF   FA8,W
3B8C:  BTFSC  xC4.7
3B8E:  BSF    FF2.7
3B90:  MOVWF  FEF
....................    } 
3B92:  INCF   21,F
3B94:  BRA    3B60
....................    BRGCON1.brp=BRP;  
3B96:  MOVF   xAB,W
3B98:  ANDLW  3F
3B9A:  MOVWF  00
3B9C:  MOVLW  C0
3B9E:  ANDWF  F70,W
3BA0:  IORWF  00,W
3BA2:  MOVWF  F70
....................    BRGCON1.sjw=SJW;  
3BA4:  SWAPF  xAF,W
3BA6:  ANDLW  30
3BA8:  MOVWF  00
3BAA:  BCF    FD8.0
3BAC:  RLCF   00,F
3BAE:  RLCF   00,F
3BB0:  MOVLW  3F
3BB2:  ANDWF  F70,W
3BB4:  IORWF  00,W
3BB6:  MOVWF  F70
....................    BRGCON2.prseg=PRSEG;  
3BB8:  MOVF   xAC,W
3BBA:  ANDLW  07
3BBC:  MOVWF  00
3BBE:  MOVLW  F8
3BC0:  ANDWF  F71,W
3BC2:  IORWF  00,W
3BC4:  MOVWF  F71
....................    BRGCON2.seg1ph=PHSEG1;  
3BC6:  MOVF   xAD,W
3BC8:  ANDLW  07
3BCA:  MOVWF  00
3BCC:  BCF    FD8.0
3BCE:  RLCF   00,F
3BD0:  RLCF   00,F
3BD2:  RLCF   00,F
3BD4:  MOVLW  C7
3BD6:  ANDWF  F71,W
3BD8:  IORWF  00,W
3BDA:  MOVWF  F71
....................    BRGCON2.sam=FALSE;  
3BDC:  BCF    F71.6
....................    BRGCON2.seg2phts=SEG2PHTS;   
3BDE:  BCF    F71.7
3BE0:  BTFSC  xB0.0
3BE2:  BSF    F71.7
....................    BRGCON3.seg2ph=PHSEG2;  
3BE4:  MOVF   xAE,W
3BE6:  ANDLW  07
3BE8:  MOVWF  00
3BEA:  MOVLW  F8
3BEC:  ANDWF  F72,W
3BEE:  IORWF  00,W
3BF0:  MOVWF  F72
....................    BRGCON3.wakfil=FALSE;  
3BF2:  BCF    F72.6
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
3BF4:  CLRF   xC1
3BF6:  CALL   30D8
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
3BFA:  MOVLW  04
3BFC:  MOVWF  xC1
3BFE:  CALL   30D8
3C02:  CLRF   18
3C04:  BTFSC  FF2.7
3C06:  BSF    18.7
3C08:  BCF    FF2.7
....................    can_set_id(RX0MASK,0xFFFF,CAN_USE_EXTENDED_ID); 
3C0A:  MOVLW  0F
3C0C:  MOVLB  1
3C0E:  MOVWF  x12
3C10:  MOVLW  1B
3C12:  MOVWF  x11
3C14:  CLRF   x16
3C16:  CLRF   x15
3C18:  MOVLW  FF
3C1A:  MOVWF  x14
3C1C:  MOVWF  x13
3C1E:  CLRF   x17
3C20:  MOVLB  0
3C22:  CALL   1F30
3C26:  BTFSC  18.7
3C28:  BSF    FF2.7
....................    can_set_id(RX0FILTER0,MAKE16((ADRESS >>5) & 0x07,(ADRESS << 3) & 0xF8),CAN_USE_EXTENDED_ID); 
3C2A:  SWAPF  23,W
3C2C:  MOVWF  00
3C2E:  RRCF   00,F
3C30:  MOVLW  07
3C32:  ANDWF  00,F
3C34:  MOVF   00,W
3C36:  ANDLW  07
3C38:  MOVWF  xC2
3C3A:  RLCF   23,W
3C3C:  MOVWF  00
3C3E:  RLCF   00,F
3C40:  RLCF   00,F
3C42:  MOVLW  F8
3C44:  ANDWF  00,F
3C46:  MOVF   00,W
3C48:  ANDLW  F8
3C4A:  MOVWF  xC4
3C4C:  MOVFF  C2,C6
3C50:  MOVWF  xC5
3C52:  CLRF   18
3C54:  BTFSC  FF2.7
3C56:  BSF    18.7
3C58:  BCF    FF2.7
3C5A:  MOVLW  0F
3C5C:  MOVLB  1
3C5E:  MOVWF  x12
3C60:  MOVLW  03
3C62:  MOVWF  x11
3C64:  CLRF   x16
3C66:  CLRF   x15
3C68:  MOVFF  C2,114
3C6C:  MOVFF  C4,113
3C70:  CLRF   x17
3C72:  MOVLB  0
3C74:  CALL   1F30
3C78:  BTFSC  18.7
3C7A:  BSF    FF2.7
3C7C:  CLRF   18
3C7E:  BTFSC  FF2.7
3C80:  BSF    18.7
3C82:  BCF    FF2.7
....................    can_set_id(RX0FILTER1,0x69F0,CAN_USE_EXTENDED_ID); 
3C84:  MOVLW  0F
3C86:  MOVLB  1
3C88:  MOVWF  x12
3C8A:  MOVLW  07
3C8C:  MOVWF  x11
3C8E:  CLRF   x16
3C90:  CLRF   x15
3C92:  MOVLW  69
3C94:  MOVWF  x14
3C96:  MOVLW  F0
3C98:  MOVWF  x13
3C9A:  CLRF   x17
3C9C:  MOVLB  0
3C9E:  CALL   1F30
3CA2:  BTFSC  18.7
3CA4:  BSF    FF2.7
3CA6:  CLRF   18
3CA8:  BTFSC  FF2.7
3CAA:  BSF    18.7
3CAC:  BCF    FF2.7
....................    can_set_id(RX1MASK,0xFFFF,CAN_USE_EXTENDED_ID); 
3CAE:  MOVLW  0F
3CB0:  MOVLB  1
3CB2:  MOVWF  x12
3CB4:  MOVLW  1F
3CB6:  MOVWF  x11
3CB8:  CLRF   x16
3CBA:  CLRF   x15
3CBC:  MOVLW  FF
3CBE:  MOVWF  x14
3CC0:  MOVWF  x13
3CC2:  CLRF   x17
3CC4:  MOVLB  0
3CC6:  CALL   1F30
3CCA:  BTFSC  18.7
3CCC:  BSF    FF2.7
....................    can_set_id(RX1FILTER2,MAKE16(ADRESS,0x00),CAN_USE_EXTENDED_ID); 
3CCE:  MOVFF  23,C2
3CD2:  CLRF   xC1
3CD4:  CLRF   18
3CD6:  BTFSC  FF2.7
3CD8:  BSF    18.7
3CDA:  BCF    FF2.7
3CDC:  MOVLW  0F
3CDE:  MOVLB  1
3CE0:  MOVWF  x12
3CE2:  MOVLW  0B
3CE4:  MOVWF  x11
3CE6:  CLRF   x16
3CE8:  CLRF   x15
3CEA:  MOVFF  23,114
3CEE:  MOVFF  C1,113
3CF2:  CLRF   x17
3CF4:  MOVLB  0
3CF6:  CALL   1F30
3CFA:  BTFSC  18.7
3CFC:  BSF    FF2.7
3CFE:  CLRF   18
3D00:  BTFSC  FF2.7
3D02:  BSF    18.7
3D04:  BCF    FF2.7
....................    can_set_id(RX1FILTER3,0x69F0,CAN_USE_EXTENDED_ID); 
3D06:  MOVLW  0F
3D08:  MOVLB  1
3D0A:  MOVWF  x12
3D0C:  MOVWF  x11
3D0E:  CLRF   x16
3D10:  CLRF   x15
3D12:  MOVLW  69
3D14:  MOVWF  x14
3D16:  MOVLW  F0
3D18:  MOVWF  x13
3D1A:  CLRF   x17
3D1C:  MOVLB  0
3D1E:  CALL   1F30
3D22:  BTFSC  18.7
3D24:  BSF    FF2.7
3D26:  CLRF   18
3D28:  BTFSC  FF2.7
3D2A:  BSF    18.7
3D2C:  BCF    FF2.7
....................    can_set_id(RX1Filter4,0xFFF0,CAN_USE_EXTENDED_ID); 
3D2E:  MOVLW  0F
3D30:  MOVLB  1
3D32:  MOVWF  x12
3D34:  MOVLW  13
3D36:  MOVWF  x11
3D38:  CLRF   x16
3D3A:  CLRF   x15
3D3C:  MOVLW  FF
3D3E:  MOVWF  x14
3D40:  MOVLW  F0
3D42:  MOVWF  x13
3D44:  CLRF   x17
3D46:  MOVLB  0
3D48:  CALL   1F30
3D4C:  BTFSC  18.7
3D4E:  BSF    FF2.7
3D50:  CLRF   18
3D52:  BTFSC  FF2.7
3D54:  BSF    18.7
3D56:  BCF    FF2.7
....................    can_set_id(RX1Filter5,0xFFF0,CAN_USE_EXTENDED_ID); 
3D58:  MOVLW  0F
3D5A:  MOVLB  1
3D5C:  MOVWF  x12
3D5E:  MOVLW  17
3D60:  MOVWF  x11
3D62:  CLRF   x16
3D64:  CLRF   x15
3D66:  MOVLW  FF
3D68:  MOVWF  x14
3D6A:  MOVLW  F0
3D6C:  MOVWF  x13
3D6E:  CLRF   x17
3D70:  MOVLB  0
3D72:  CALL   1F30
3D76:  BTFSC  18.7
3D78:  BSF    FF2.7
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
3D7A:  CLRF   xC1
3D7C:  CALL   30D8
....................    
....................    enable_interrupts(int_canrx0);  
3D80:  BSF    FA3.0
....................    enable_interrupts(int_canrx1);  
3D82:  BSF    FA3.1
....................    enable_interrupts(int_cantx0);  
3D84:  BSF    FA3.2
....................    enable_interrupts(int_cantx1);  
3D86:  BSF    FA3.3
....................    enable_interrupts(int_cantx2);  
3D88:  BSF    FA3.4
....................    enable_interrupts(int_canirx);  
3D8A:  BSF    FA3.7
....................    enable_interrupts(int_canerr);  
3D8C:  BSF    FA3.5
....................  
....................  
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD); 
3D8E:  MOVF   FC1,W
3D90:  ANDLW  C0
3D92:  IORLW  0F
3D94:  MOVWF  FC1
....................    setup_adc(ADC_OFF|ADC_TAD_MUL_0); 
3D96:  BCF    FC2.0
....................    setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_4); 
3D98:  BCF    FC6.5
3D9A:  BCF    F94.5
3D9C:  BSF    F94.4
3D9E:  BCF    F94.3
3DA0:  MOVLW  20
3DA2:  MOVWF  FC6
3DA4:  MOVLW  40
3DA6:  MOVWF  FC7
3DA8:  CLRF   18
3DAA:  BTFSC  FF2.7
3DAC:  BSF    18.7
3DAE:  BCF    FF2.7
....................    write4896(0); 
3DB0:  CLRF   xF4
3DB2:  CALL   1186
3DB6:  BTFSC  18.7
3DB8:  BSF    FF2.7
....................    if (DEBUG_MODE==NODEBUG)  setup_wdt(WDT_ON); 
3DBA:  MOVF   2F,F
3DBC:  BNZ   3DC2
3DBE:  BSF    FD1.0
....................    else setup_wdt(WDT_OFF); 
3DC0:  BRA    3DC4
3DC2:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
3DC4:  MOVLW  80
3DC6:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
3DC8:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
3DCA:  MOVLW  00
3DCC:  MOVWF  FCA
3DCE:  MOVLW  00
3DD0:  MOVWF  FCB
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
3DD2:  MOVF   FB1,W
3DD4:  ANDLW  48
3DD6:  MOVWF  FB1
....................    setup_vref(FALSE); 
3DD8:  CLRF   FB5
....................     
....................    enable_interrupts(INT_LOWVOLT); 
3DDA:  BSF    FA0.2
....................    enable_interrupts(INT_CANIRX); 
3DDC:  BSF    FA3.7
....................    enable_interrupts(INT_CANERR); 
3DDE:  BSF    FA3.5
....................    enable_interrupts(INT_CANRX1); 
3DE0:  BSF    FA3.1
....................    enable_interrupts(INT_CANRX0); 
3DE2:  BSF    FA3.0
....................    enable_interrupts(INT_OSCF); 
3DE4:  BSF    FA0.7
....................    enable_interrupts(GLOBAL); 
3DE6:  MOVLW  C0
3DE8:  IORWF  FF2,F
....................    
.................... //Setup_Oscillator parameter not selected from Intr Oscillotar Config tab 
....................    out_value=0; 
3DEA:  CLRF   24
....................    // TODO: USER CODE!! 
....................    while(true){ 
....................    restart_wdt(); 
3DEC:  CLRWDT
....................    if(can_Pop(send_id,rbuffer,lenght,stat)) proc_can(send_id,rbuffer,lenght); 
3DEE:  MOVLB  1
3DF0:  CLRF   x03
3DF2:  MOVLW  B2
3DF4:  MOVWF  x02
*
3F5C:  MOVF   01,F
3F5E:  BZ    3F80
3F60:  MOVFF  BE,C4
3F64:  MOVFF  BD,C3
3F68:  MOVFF  BC,C2
3F6C:  MOVFF  BB,C1
3F70:  MOVLB  0
3F72:  CLRF   xC6
3F74:  MOVLW  B2
3F76:  MOVWF  xC5
3F78:  MOVFF  B9,C7
3F7C:  GOTO   33E8
....................    output_refresh(); 
3F80:  MOVLB  0
3F82:  GOTO   371A
3F86:  CLRF   18
3F88:  BTFSC  FF2.7
3F8A:  BSF    18.7
3F8C:  BCF    FF2.7
....................   /* if(DEBUG_MODE==D_RS232)  
....................    { 
....................       delay_ms(500); 
....................       printf("OUTPUT:%X\n\r",out_value); 
....................    }*/ 
....................    write4896(out_value); 
3F8E:  MOVFF  24,F4
3F92:  CALL   1186
3F96:  BTFSC  18.7
3F98:  BSF    FF2.7
3F9A:  CLRF   18
3F9C:  BTFSC  FF2.7
3F9E:  BSF    18.7
3FA0:  BCF    FF2.7
....................    canTransmit ( ); 
3FA2:  CALL   2134
3FA6:  BTFSC  18.7
3FA8:  BSF    FF2.7
....................    } 
3FAA:  BRA    3DEC
....................  
....................  
.................... } 
3FAC:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0F1E   BROWNOUT WDT128 WDT BORV20 PUT
   Word  3: 0400   NOPBADEN LPT1OSC NOMCLR
   Word  4: 0091   STVREN NODEBUG NOLVP BBSIZ2K NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
